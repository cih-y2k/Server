/*
 * product   : NewsGate - news search WEB server
 * copyright : Copyright (c) 2005-2016 Karen Arutyunov
 * licenses  : CC BY-NC-SA 3.0; see accompanying LICENSE file
 *             Commercial; contact karen.arutyunov@gmail.com
 */

// Copyright (C) 2005-2008 Karen Arutyunov
//
// This program was generated by MySQL Class Generating Compiler
// MySQLClassGen (TM)
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA

#ifndef _NEWSGATE_AD_DB_ADSELECTOR__1784554767_
#define _NEWSGATE_AD_DB_ADSELECTOR__1784554767_

#include <limits.h>

#include <string>
#include <sstream>

#include <El/Exception.hpp>
#include <El/MySQL/DB.hpp>

namespace NewsGate
{
  namespace Ad
  {
    namespace DB
    {
//
// AdSelector class declaration
//
      class AdSelector: public El::MySQL::Row
      {
      public:
        EL_EXCEPTION(Exception, El::MySQL::Exception);
        EL_EXCEPTION(IsNull, Exception);

      public:
        AdSelector(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
          throw(Exception, El::Exception);

        El::MySQL::String status() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong update_num() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLong pcws_weight_zones() const
         throw(Exception, El::Exception);

        El::MySQL::Double pcws_reduction_rate() const
         throw(Exception, El::Exception);

      };

//
// AdSelector class definition
//
      inline
      AdSelector::AdSelector(El::MySQL::Result* result, unsigned long use_columns)
        throw(Exception, El::Exception)
          : Row(result)
      {
        unsigned long num_columns = std::min(use_columns, (unsigned long)4);

        if(result->num_fields() != num_columns)
        {
          std::ostringstream ostr;
          ostr << "AdSelector::AdSelector: unexpected number of fields "
               << result->num_fields() << " instead of " << num_columns;

          throw Exception(ostr.str());
        }

        if(use_columns >= 0)
        {
          return;
        }

        enum_field_types type = (*result)[0].type;

        if(type != 254)
        {
          std::ostringstream ostr;
          ostr << "AdSelector::AdSelector: unexpected type " << type
               << " instead of 254 for field status";

          throw Exception(ostr.str());
        }

        unsigned int flags = 
          (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "AdSelector::AdSelector: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field status";

          throw Exception(ostr.str());
        }

        const char* name = (*result)[0].name;

        if(strcmp(name, "status"))
        {
          std::ostringstream ostr;
          ostr << "AdSelector::AdSelector: unexpected name " << name
               << " instead of status for field status";

          throw Exception(ostr.str());
        }

        if(use_columns >= 1)
        {
          return;
        }

        type = (*result)[1].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "AdSelector::AdSelector: unexpected type " << type
               << " instead of 8 for field update_num";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "AdSelector::AdSelector: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field update_num";

          throw Exception(ostr.str());
        }

        name = (*result)[1].name;

        if(strcmp(name, "update_num"))
        {
          std::ostringstream ostr;
          ostr << "AdSelector::AdSelector: unexpected name " << name
               << " instead of update_num for field update_num";

          throw Exception(ostr.str());
        }

        if(use_columns >= 2)
        {
          return;
        }

        type = (*result)[2].type;

        if(type != 3)
        {
          std::ostringstream ostr;
          ostr << "AdSelector::AdSelector: unexpected type " << type
               << " instead of 3 for field pcws_weight_zones";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "AdSelector::AdSelector: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field pcws_weight_zones";

          throw Exception(ostr.str());
        }

        name = (*result)[2].name;

        if(strcmp(name, "pcws_weight_zones"))
        {
          std::ostringstream ostr;
          ostr << "AdSelector::AdSelector: unexpected name " << name
               << " instead of pcws_weight_zones for field pcws_weight_zones";

          throw Exception(ostr.str());
        }

        if(use_columns >= 3)
        {
          return;
        }

        type = (*result)[3].type;

        if(type != 5)
        {
          std::ostringstream ostr;
          ostr << "AdSelector::AdSelector: unexpected type " << type
               << " instead of 5 for field pcws_reduction_rate";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[3].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "AdSelector::AdSelector: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field pcws_reduction_rate";

          throw Exception(ostr.str());
        }

        name = (*result)[3].name;

        if(strcmp(name, "pcws_reduction_rate"))
        {
          std::ostringstream ostr;
          ostr << "AdSelector::AdSelector: unexpected name " << name
               << " instead of pcws_reduction_rate for field pcws_reduction_rate";

          throw Exception(ostr.str());
        }

      }

      inline
      El::MySQL::String
      AdSelector::status() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("AdSelector::status: row_ is 0");
        }

        if(0 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "AdSelector::status: unexpected index 0 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[0] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[0], lengths[0]);

        return tmp;
      }

      inline
      El::MySQL::UnsignedLongLong
      AdSelector::update_num() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("AdSelector::update_num: row_ is 0");
        }

        if(1 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "AdSelector::update_num: unexpected index 1 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[1] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[1], lengths[1]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "AdSelector::update_num: failed to convert 'update_num' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::UnsignedLong
      AdSelector::pcws_weight_zones() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("AdSelector::pcws_weight_zones: row_ is 0");
        }

        if(2 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "AdSelector::pcws_weight_zones: unexpected index 2 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long value = 0;
        bool is_null = row_[2] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[2], lengths[2]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "AdSelector::pcws_weight_zones: failed to convert 'pcws_weight_zones' field data"
              " to unsigned long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLong(is_null, value);
      }

      inline
      El::MySQL::Double
      AdSelector::pcws_reduction_rate() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("AdSelector::pcws_reduction_rate: row_ is 0");
        }

        if(3 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "AdSelector::pcws_reduction_rate: unexpected index 3 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        double value = 0;
        bool is_null = row_[3] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[3], lengths[3]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "AdSelector::pcws_reduction_rate: failed to convert 'pcws_reduction_rate' field data"
              " to double";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::Double(is_null, value);
      }

    }
  }
}

namespace NewsGate
{
  namespace Ad
  {
    namespace DB
    {
//
// Page class declaration
//
      class Page: public El::MySQL::Row
      {
      public:
        EL_EXCEPTION(Exception, El::MySQL::Exception);
        EL_EXCEPTION(IsNull, Exception);

      public:
        Page(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
          throw(Exception, El::Exception);

        El::MySQL::UnsignedLong id() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLong max_ad_num() const
         throw(Exception, El::Exception);

      };

//
// Page class definition
//
      inline
      Page::Page(El::MySQL::Result* result, unsigned long use_columns)
        throw(Exception, El::Exception)
          : Row(result)
      {
        unsigned long num_columns = std::min(use_columns, (unsigned long)2);

        if(result->num_fields() != num_columns)
        {
          std::ostringstream ostr;
          ostr << "Page::Page: unexpected number of fields "
               << result->num_fields() << " instead of " << num_columns;

          throw Exception(ostr.str());
        }

        if(use_columns >= 0)
        {
          return;
        }

        enum_field_types type = (*result)[0].type;

        if(type != 3)
        {
          std::ostringstream ostr;
          ostr << "Page::Page: unexpected type " << type
               << " instead of 3 for field id";

          throw Exception(ostr.str());
        }

        unsigned int flags = 
          (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "Page::Page: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field id";

          throw Exception(ostr.str());
        }

        const char* name = (*result)[0].name;

        if(strcmp(name, "id"))
        {
          std::ostringstream ostr;
          ostr << "Page::Page: unexpected name " << name
               << " instead of id for field id";

          throw Exception(ostr.str());
        }

        if(use_columns >= 1)
        {
          return;
        }

        type = (*result)[1].type;

        if(type != 3)
        {
          std::ostringstream ostr;
          ostr << "Page::Page: unexpected type " << type
               << " instead of 3 for field max_ad_num";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "Page::Page: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field max_ad_num";

          throw Exception(ostr.str());
        }

        name = (*result)[1].name;

        if(strcmp(name, "max_ad_num"))
        {
          std::ostringstream ostr;
          ostr << "Page::Page: unexpected name " << name
               << " instead of max_ad_num for field max_ad_num";

          throw Exception(ostr.str());
        }

      }

      inline
      El::MySQL::UnsignedLong
      Page::id() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Page::id: row_ is 0");
        }

        if(0 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Page::id: unexpected index 0 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long value = 0;
        bool is_null = row_[0] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[0], lengths[0]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "Page::id: failed to convert 'id' field data"
              " to unsigned long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLong(is_null, value);
      }

      inline
      El::MySQL::UnsignedLong
      Page::max_ad_num() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Page::max_ad_num: row_ is 0");
        }

        if(1 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Page::max_ad_num: unexpected index 1 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long value = 0;
        bool is_null = row_[1] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[1], lengths[1]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "Page::max_ad_num: failed to convert 'max_ad_num' field data"
              " to unsigned long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLong(is_null, value);
      }

    }
  }
}

namespace NewsGate
{
  namespace Ad
  {
    namespace DB
    {
//
// PageAdvRestriction class declaration
//
      class PageAdvRestriction: public El::MySQL::Row
      {
      public:
        EL_EXCEPTION(Exception, El::MySQL::Exception);
        EL_EXCEPTION(IsNull, Exception);

      public:
        PageAdvRestriction(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
          throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong advertiser() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLong max_ad_num() const
         throw(Exception, El::Exception);

      };

//
// PageAdvRestriction class definition
//
      inline
      PageAdvRestriction::PageAdvRestriction(El::MySQL::Result* result, unsigned long use_columns)
        throw(Exception, El::Exception)
          : Row(result)
      {
        unsigned long num_columns = std::min(use_columns, (unsigned long)2);

        if(result->num_fields() != num_columns)
        {
          std::ostringstream ostr;
          ostr << "PageAdvRestriction::PageAdvRestriction: unexpected number of fields "
               << result->num_fields() << " instead of " << num_columns;

          throw Exception(ostr.str());
        }

        if(use_columns >= 0)
        {
          return;
        }

        enum_field_types type = (*result)[0].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "PageAdvRestriction::PageAdvRestriction: unexpected type " << type
               << " instead of 8 for field advertiser";

          throw Exception(ostr.str());
        }

        unsigned int flags = 
          (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "PageAdvRestriction::PageAdvRestriction: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field advertiser";

          throw Exception(ostr.str());
        }

        const char* name = (*result)[0].name;

        if(strcmp(name, "advertiser"))
        {
          std::ostringstream ostr;
          ostr << "PageAdvRestriction::PageAdvRestriction: unexpected name " << name
               << " instead of advertiser for field advertiser";

          throw Exception(ostr.str());
        }

        if(use_columns >= 1)
        {
          return;
        }

        type = (*result)[1].type;

        if(type != 3)
        {
          std::ostringstream ostr;
          ostr << "PageAdvRestriction::PageAdvRestriction: unexpected type " << type
               << " instead of 3 for field max_ad_num";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "PageAdvRestriction::PageAdvRestriction: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field max_ad_num";

          throw Exception(ostr.str());
        }

        name = (*result)[1].name;

        if(strcmp(name, "max_ad_num"))
        {
          std::ostringstream ostr;
          ostr << "PageAdvRestriction::PageAdvRestriction: unexpected name " << name
               << " instead of max_ad_num for field max_ad_num";

          throw Exception(ostr.str());
        }

      }

      inline
      El::MySQL::UnsignedLongLong
      PageAdvRestriction::advertiser() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("PageAdvRestriction::advertiser: row_ is 0");
        }

        if(0 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "PageAdvRestriction::advertiser: unexpected index 0 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[0] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[0], lengths[0]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "PageAdvRestriction::advertiser: failed to convert 'advertiser' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::UnsignedLong
      PageAdvRestriction::max_ad_num() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("PageAdvRestriction::max_ad_num: row_ is 0");
        }

        if(1 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "PageAdvRestriction::max_ad_num: unexpected index 1 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long value = 0;
        bool is_null = row_[1] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[1], lengths[1]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "PageAdvRestriction::max_ad_num: failed to convert 'max_ad_num' field data"
              " to unsigned long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLong(is_null, value);
      }

    }
  }
}

namespace NewsGate
{
  namespace Ad
  {
    namespace DB
    {
//
// AdPageAdvAdvRestriction class declaration
//
      class AdPageAdvAdvRestriction: public El::MySQL::Row
      {
      public:
        EL_EXCEPTION(Exception, El::MySQL::Exception);
        EL_EXCEPTION(IsNull, Exception);

      public:
        AdPageAdvAdvRestriction(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
          throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong advertiser() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong advertiser2() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLong max_ad_num() const
         throw(Exception, El::Exception);

      };

//
// AdPageAdvAdvRestriction class definition
//
      inline
      AdPageAdvAdvRestriction::AdPageAdvAdvRestriction(El::MySQL::Result* result, unsigned long use_columns)
        throw(Exception, El::Exception)
          : Row(result)
      {
        unsigned long num_columns = std::min(use_columns, (unsigned long)3);

        if(result->num_fields() != num_columns)
        {
          std::ostringstream ostr;
          ostr << "AdPageAdvAdvRestriction::AdPageAdvAdvRestriction: unexpected number of fields "
               << result->num_fields() << " instead of " << num_columns;

          throw Exception(ostr.str());
        }

        if(use_columns >= 0)
        {
          return;
        }

        enum_field_types type = (*result)[0].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "AdPageAdvAdvRestriction::AdPageAdvAdvRestriction: unexpected type " << type
               << " instead of 8 for field advertiser";

          throw Exception(ostr.str());
        }

        unsigned int flags = 
          (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "AdPageAdvAdvRestriction::AdPageAdvAdvRestriction: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field advertiser";

          throw Exception(ostr.str());
        }

        const char* name = (*result)[0].name;

        if(strcmp(name, "advertiser"))
        {
          std::ostringstream ostr;
          ostr << "AdPageAdvAdvRestriction::AdPageAdvAdvRestriction: unexpected name " << name
               << " instead of advertiser for field advertiser";

          throw Exception(ostr.str());
        }

        if(use_columns >= 1)
        {
          return;
        }

        type = (*result)[1].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "AdPageAdvAdvRestriction::AdPageAdvAdvRestriction: unexpected type " << type
               << " instead of 8 for field advertiser2";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "AdPageAdvAdvRestriction::AdPageAdvAdvRestriction: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field advertiser2";

          throw Exception(ostr.str());
        }

        name = (*result)[1].name;

        if(strcmp(name, "advertiser2"))
        {
          std::ostringstream ostr;
          ostr << "AdPageAdvAdvRestriction::AdPageAdvAdvRestriction: unexpected name " << name
               << " instead of advertiser2 for field advertiser2";

          throw Exception(ostr.str());
        }

        if(use_columns >= 2)
        {
          return;
        }

        type = (*result)[2].type;

        if(type != 3)
        {
          std::ostringstream ostr;
          ostr << "AdPageAdvAdvRestriction::AdPageAdvAdvRestriction: unexpected type " << type
               << " instead of 3 for field max_ad_num";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "AdPageAdvAdvRestriction::AdPageAdvAdvRestriction: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field max_ad_num";

          throw Exception(ostr.str());
        }

        name = (*result)[2].name;

        if(strcmp(name, "max_ad_num"))
        {
          std::ostringstream ostr;
          ostr << "AdPageAdvAdvRestriction::AdPageAdvAdvRestriction: unexpected name " << name
               << " instead of max_ad_num for field max_ad_num";

          throw Exception(ostr.str());
        }

      }

      inline
      El::MySQL::UnsignedLongLong
      AdPageAdvAdvRestriction::advertiser() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("AdPageAdvAdvRestriction::advertiser: row_ is 0");
        }

        if(0 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "AdPageAdvAdvRestriction::advertiser: unexpected index 0 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[0] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[0], lengths[0]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "AdPageAdvAdvRestriction::advertiser: failed to convert 'advertiser' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::UnsignedLongLong
      AdPageAdvAdvRestriction::advertiser2() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("AdPageAdvAdvRestriction::advertiser2: row_ is 0");
        }

        if(1 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "AdPageAdvAdvRestriction::advertiser2: unexpected index 1 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[1] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[1], lengths[1]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "AdPageAdvAdvRestriction::advertiser2: failed to convert 'advertiser2' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::UnsignedLong
      AdPageAdvAdvRestriction::max_ad_num() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("AdPageAdvAdvRestriction::max_ad_num: row_ is 0");
        }

        if(2 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "AdPageAdvAdvRestriction::max_ad_num: unexpected index 2 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long value = 0;
        bool is_null = row_[2] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[2], lengths[2]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "AdPageAdvAdvRestriction::max_ad_num: failed to convert 'max_ad_num' field data"
              " to unsigned long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLong(is_null, value);
      }

    }
  }
}

namespace NewsGate
{
  namespace Ad
  {
    namespace DB
    {
//
// Placement class declaration
//
      class Placement: public El::MySQL::Row
      {
      public:
        EL_EXCEPTION(Exception, El::MySQL::Exception);
        EL_EXCEPTION(IsNull, Exception);

      public:
        Placement(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
          throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong id() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong group_id() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong group_cap_min_time() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong slot() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLong width() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLong height() const
         throw(Exception, El::Exception);

        El::MySQL::Double weight() const
         throw(Exception, El::Exception);

        El::MySQL::String inject() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong advertiser() const
         throw(Exception, El::Exception);

        El::MySQL::String text() const
         throw(Exception, El::Exception);

      };

//
// Placement class definition
//
      inline
      Placement::Placement(El::MySQL::Result* result, unsigned long use_columns)
        throw(Exception, El::Exception)
          : Row(result)
      {
        unsigned long num_columns = std::min(use_columns, (unsigned long)10);

        if(result->num_fields() != num_columns)
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected number of fields "
               << result->num_fields() << " instead of " << num_columns;

          throw Exception(ostr.str());
        }

        if(use_columns >= 0)
        {
          return;
        }

        enum_field_types type = (*result)[0].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected type " << type
               << " instead of 8 for field id";

          throw Exception(ostr.str());
        }

        unsigned int flags = 
          (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field id";

          throw Exception(ostr.str());
        }

        const char* name = (*result)[0].name;

        if(strcmp(name, "id"))
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected name " << name
               << " instead of id for field id";

          throw Exception(ostr.str());
        }

        if(use_columns >= 1)
        {
          return;
        }

        type = (*result)[1].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected type " << type
               << " instead of 8 for field group_id";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x20)
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected flags 0x" << std::hex
               << flags << " instead of 0x20 for field group_id";

          throw Exception(ostr.str());
        }

        name = (*result)[1].name;

        if(strcmp(name, "group_id"))
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected name " << name
               << " instead of group_id for field group_id";

          throw Exception(ostr.str());
        }

        if(use_columns >= 2)
        {
          return;
        }

        type = (*result)[2].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected type " << type
               << " instead of 8 for field group_cap_min_time";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x20)
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected flags 0x" << std::hex
               << flags << " instead of 0x20 for field group_cap_min_time";

          throw Exception(ostr.str());
        }

        name = (*result)[2].name;

        if(strcmp(name, "group_cap_min_time"))
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected name " << name
               << " instead of group_cap_min_time for field group_cap_min_time";

          throw Exception(ostr.str());
        }

        if(use_columns >= 3)
        {
          return;
        }

        type = (*result)[3].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected type " << type
               << " instead of 8 for field slot";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[3].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field slot";

          throw Exception(ostr.str());
        }

        name = (*result)[3].name;

        if(strcmp(name, "slot"))
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected name " << name
               << " instead of slot for field slot";

          throw Exception(ostr.str());
        }

        if(use_columns >= 4)
        {
          return;
        }

        type = (*result)[4].type;

        if(type != 3)
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected type " << type
               << " instead of 3 for field width";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[4].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x20)
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected flags 0x" << std::hex
               << flags << " instead of 0x20 for field width";

          throw Exception(ostr.str());
        }

        name = (*result)[4].name;

        if(strcmp(name, "width"))
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected name " << name
               << " instead of width for field width";

          throw Exception(ostr.str());
        }

        if(use_columns >= 5)
        {
          return;
        }

        type = (*result)[5].type;

        if(type != 3)
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected type " << type
               << " instead of 3 for field height";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[5].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x20)
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected flags 0x" << std::hex
               << flags << " instead of 0x20 for field height";

          throw Exception(ostr.str());
        }

        name = (*result)[5].name;

        if(strcmp(name, "height"))
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected name " << name
               << " instead of height for field height";

          throw Exception(ostr.str());
        }

        if(use_columns >= 6)
        {
          return;
        }

        type = (*result)[6].type;

        if(type != 5)
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected type " << type
               << " instead of 5 for field weight";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[6].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x80)
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected flags 0x" << std::hex
               << flags << " instead of 0x80 for field weight";

          throw Exception(ostr.str());
        }

        name = (*result)[6].name;

        if(strcmp(name, "weight"))
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected name " << name
               << " instead of weight for field weight";

          throw Exception(ostr.str());
        }

        if(use_columns >= 7)
        {
          return;
        }

        type = (*result)[7].type;

        if(type != 254)
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected type " << type
               << " instead of 254 for field inject";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[7].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field inject";

          throw Exception(ostr.str());
        }

        name = (*result)[7].name;

        if(strcmp(name, "inject"))
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected name " << name
               << " instead of inject for field inject";

          throw Exception(ostr.str());
        }

        if(use_columns >= 8)
        {
          return;
        }

        type = (*result)[8].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected type " << type
               << " instead of 8 for field advertiser";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[8].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x20)
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected flags 0x" << std::hex
               << flags << " instead of 0x20 for field advertiser";

          throw Exception(ostr.str());
        }

        name = (*result)[8].name;

        if(strcmp(name, "advertiser"))
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected name " << name
               << " instead of advertiser for field advertiser";

          throw Exception(ostr.str());
        }

        if(use_columns >= 9)
        {
          return;
        }

        type = (*result)[9].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected type " << type
               << " instead of 253 for field text";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[9].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field text";

          throw Exception(ostr.str());
        }

        name = (*result)[9].name;

        if(strcmp(name, "text"))
        {
          std::ostringstream ostr;
          ostr << "Placement::Placement: unexpected name " << name
               << " instead of text for field text";

          throw Exception(ostr.str());
        }

      }

      inline
      El::MySQL::UnsignedLongLong
      Placement::id() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Placement::id: row_ is 0");
        }

        if(0 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Placement::id: unexpected index 0 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[0] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[0], lengths[0]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "Placement::id: failed to convert 'id' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::UnsignedLongLong
      Placement::group_id() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Placement::group_id: row_ is 0");
        }

        if(1 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Placement::group_id: unexpected index 1 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[1] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[1], lengths[1]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "Placement::group_id: failed to convert 'group_id' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::UnsignedLongLong
      Placement::group_cap_min_time() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Placement::group_cap_min_time: row_ is 0");
        }

        if(2 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Placement::group_cap_min_time: unexpected index 2 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[2] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[2], lengths[2]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "Placement::group_cap_min_time: failed to convert 'group_cap_min_time' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::UnsignedLongLong
      Placement::slot() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Placement::slot: row_ is 0");
        }

        if(3 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Placement::slot: unexpected index 3 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[3] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[3], lengths[3]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "Placement::slot: failed to convert 'slot' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::UnsignedLong
      Placement::width() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Placement::width: row_ is 0");
        }

        if(4 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Placement::width: unexpected index 4 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long value = 0;
        bool is_null = row_[4] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[4], lengths[4]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "Placement::width: failed to convert 'width' field data"
              " to unsigned long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLong(is_null, value);
      }

      inline
      El::MySQL::UnsignedLong
      Placement::height() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Placement::height: row_ is 0");
        }

        if(5 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Placement::height: unexpected index 5 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long value = 0;
        bool is_null = row_[5] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[5], lengths[5]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "Placement::height: failed to convert 'height' field data"
              " to unsigned long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLong(is_null, value);
      }

      inline
      El::MySQL::Double
      Placement::weight() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Placement::weight: row_ is 0");
        }

        if(6 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Placement::weight: unexpected index 6 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        double value = 0;
        bool is_null = row_[6] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[6], lengths[6]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "Placement::weight: failed to convert 'weight' field data"
              " to double";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::Double(is_null, value);
      }

      inline
      El::MySQL::String
      Placement::inject() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Placement::inject: row_ is 0");
        }

        if(7 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Placement::inject: unexpected index 7 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[7] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[7], lengths[7]);

        return tmp;
      }

      inline
      El::MySQL::UnsignedLongLong
      Placement::advertiser() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Placement::advertiser: row_ is 0");
        }

        if(8 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Placement::advertiser: unexpected index 8 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[8] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[8], lengths[8]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "Placement::advertiser: failed to convert 'advertiser' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::String
      Placement::text() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Placement::text: row_ is 0");
        }

        if(9 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Placement::text: unexpected index 9 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[9] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[9], lengths[9]);

        return tmp;
      }

    }
  }
}

namespace NewsGate
{
  namespace Ad
  {
    namespace DB
    {
//
// CounterPlacement class declaration
//
      class CounterPlacement: public El::MySQL::Row
      {
      public:
        EL_EXCEPTION(Exception, El::MySQL::Exception);
        EL_EXCEPTION(IsNull, Exception);

      public:
        CounterPlacement(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
          throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong id() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong group_id() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong group_cap_min_time() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong advertiser() const
         throw(Exception, El::Exception);

        El::MySQL::String text() const
         throw(Exception, El::Exception);

      };

//
// CounterPlacement class definition
//
      inline
      CounterPlacement::CounterPlacement(El::MySQL::Result* result, unsigned long use_columns)
        throw(Exception, El::Exception)
          : Row(result)
      {
        unsigned long num_columns = std::min(use_columns, (unsigned long)5);

        if(result->num_fields() != num_columns)
        {
          std::ostringstream ostr;
          ostr << "CounterPlacement::CounterPlacement: unexpected number of fields "
               << result->num_fields() << " instead of " << num_columns;

          throw Exception(ostr.str());
        }

        if(use_columns >= 0)
        {
          return;
        }

        enum_field_types type = (*result)[0].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "CounterPlacement::CounterPlacement: unexpected type " << type
               << " instead of 8 for field id";

          throw Exception(ostr.str());
        }

        unsigned int flags = 
          (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "CounterPlacement::CounterPlacement: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field id";

          throw Exception(ostr.str());
        }

        const char* name = (*result)[0].name;

        if(strcmp(name, "id"))
        {
          std::ostringstream ostr;
          ostr << "CounterPlacement::CounterPlacement: unexpected name " << name
               << " instead of id for field id";

          throw Exception(ostr.str());
        }

        if(use_columns >= 1)
        {
          return;
        }

        type = (*result)[1].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "CounterPlacement::CounterPlacement: unexpected type " << type
               << " instead of 8 for field group_id";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x20)
        {
          std::ostringstream ostr;
          ostr << "CounterPlacement::CounterPlacement: unexpected flags 0x" << std::hex
               << flags << " instead of 0x20 for field group_id";

          throw Exception(ostr.str());
        }

        name = (*result)[1].name;

        if(strcmp(name, "group_id"))
        {
          std::ostringstream ostr;
          ostr << "CounterPlacement::CounterPlacement: unexpected name " << name
               << " instead of group_id for field group_id";

          throw Exception(ostr.str());
        }

        if(use_columns >= 2)
        {
          return;
        }

        type = (*result)[2].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "CounterPlacement::CounterPlacement: unexpected type " << type
               << " instead of 8 for field group_cap_min_time";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x20)
        {
          std::ostringstream ostr;
          ostr << "CounterPlacement::CounterPlacement: unexpected flags 0x" << std::hex
               << flags << " instead of 0x20 for field group_cap_min_time";

          throw Exception(ostr.str());
        }

        name = (*result)[2].name;

        if(strcmp(name, "group_cap_min_time"))
        {
          std::ostringstream ostr;
          ostr << "CounterPlacement::CounterPlacement: unexpected name " << name
               << " instead of group_cap_min_time for field group_cap_min_time";

          throw Exception(ostr.str());
        }

        if(use_columns >= 3)
        {
          return;
        }

        type = (*result)[3].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "CounterPlacement::CounterPlacement: unexpected type " << type
               << " instead of 8 for field advertiser";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[3].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "CounterPlacement::CounterPlacement: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field advertiser";

          throw Exception(ostr.str());
        }

        name = (*result)[3].name;

        if(strcmp(name, "advertiser"))
        {
          std::ostringstream ostr;
          ostr << "CounterPlacement::CounterPlacement: unexpected name " << name
               << " instead of advertiser for field advertiser";

          throw Exception(ostr.str());
        }

        if(use_columns >= 4)
        {
          return;
        }

        type = (*result)[4].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "CounterPlacement::CounterPlacement: unexpected type " << type
               << " instead of 253 for field text";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[4].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "CounterPlacement::CounterPlacement: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field text";

          throw Exception(ostr.str());
        }

        name = (*result)[4].name;

        if(strcmp(name, "text"))
        {
          std::ostringstream ostr;
          ostr << "CounterPlacement::CounterPlacement: unexpected name " << name
               << " instead of text for field text";

          throw Exception(ostr.str());
        }

      }

      inline
      El::MySQL::UnsignedLongLong
      CounterPlacement::id() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CounterPlacement::id: row_ is 0");
        }

        if(0 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CounterPlacement::id: unexpected index 0 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[0] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[0], lengths[0]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::id: failed to convert 'id' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::UnsignedLongLong
      CounterPlacement::group_id() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CounterPlacement::group_id: row_ is 0");
        }

        if(1 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CounterPlacement::group_id: unexpected index 1 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[1] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[1], lengths[1]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::group_id: failed to convert 'group_id' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::UnsignedLongLong
      CounterPlacement::group_cap_min_time() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CounterPlacement::group_cap_min_time: row_ is 0");
        }

        if(2 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CounterPlacement::group_cap_min_time: unexpected index 2 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[2] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[2], lengths[2]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::group_cap_min_time: failed to convert 'group_cap_min_time' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::UnsignedLongLong
      CounterPlacement::advertiser() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CounterPlacement::advertiser: row_ is 0");
        }

        if(3 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CounterPlacement::advertiser: unexpected index 3 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[3] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[3], lengths[3]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "CounterPlacement::advertiser: failed to convert 'advertiser' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::String
      CounterPlacement::text() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CounterPlacement::text: row_ is 0");
        }

        if(4 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CounterPlacement::text: unexpected index 4 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[4] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[4], lengths[4]);

        return tmp;
      }

    }
  }
}

namespace NewsGate
{
  namespace Ad
  {
    namespace DB
    {
//
// Condition class declaration
//
      class Condition: public El::MySQL::Row
      {
      public:
        EL_EXCEPTION(Exception, El::MySQL::Exception);
        EL_EXCEPTION(IsNull, Exception);

      public:
        Condition(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
          throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong id() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedChar rnd_mod() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedChar rnd_mod_from() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedChar rnd_mod_to() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLong group_freq_cap() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLong group_count_cap() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong query_types() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong query_type_exclusions() const
         throw(Exception, El::Exception);

        El::MySQL::String page_sources() const
         throw(Exception, El::Exception);

        El::MySQL::String page_source_exclusions() const
         throw(Exception, El::Exception);

        El::MySQL::String message_sources() const
         throw(Exception, El::Exception);

        El::MySQL::String message_source_exclusions() const
         throw(Exception, El::Exception);

        El::MySQL::String page_categories() const
         throw(Exception, El::Exception);

        El::MySQL::String page_category_exclusions() const
         throw(Exception, El::Exception);

        El::MySQL::String message_categories() const
         throw(Exception, El::Exception);

        El::MySQL::String message_category_exclusions() const
         throw(Exception, El::Exception);

        El::MySQL::String search_engines() const
         throw(Exception, El::Exception);

        El::MySQL::String search_engine_exclusions() const
         throw(Exception, El::Exception);

        El::MySQL::String crawlers() const
         throw(Exception, El::Exception);

        El::MySQL::String crawler_exclusions() const
         throw(Exception, El::Exception);

        El::MySQL::String languages() const
         throw(Exception, El::Exception);

        El::MySQL::String language_exclusions() const
         throw(Exception, El::Exception);

        El::MySQL::String countries() const
         throw(Exception, El::Exception);

        El::MySQL::String country_exclusions() const
         throw(Exception, El::Exception);

        El::MySQL::String ip_masks() const
         throw(Exception, El::Exception);

        El::MySQL::String ip_mask_exclusions() const
         throw(Exception, El::Exception);

        El::MySQL::String tags() const
         throw(Exception, El::Exception);

        El::MySQL::String tag_exclusions() const
         throw(Exception, El::Exception);

        El::MySQL::String referers() const
         throw(Exception, El::Exception);

        El::MySQL::String referer_exclusions() const
         throw(Exception, El::Exception);

        El::MySQL::String content_languages() const
         throw(Exception, El::Exception);

        El::MySQL::String content_language_exclusions() const
         throw(Exception, El::Exception);

      };

//
// Condition class definition
//
      inline
      Condition::Condition(El::MySQL::Result* result, unsigned long use_columns)
        throw(Exception, El::Exception)
          : Row(result)
      {
        unsigned long num_columns = std::min(use_columns, (unsigned long)32);

        if(result->num_fields() != num_columns)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected number of fields "
               << result->num_fields() << " instead of " << num_columns;

          throw Exception(ostr.str());
        }

        if(use_columns >= 0)
        {
          return;
        }

        enum_field_types type = (*result)[0].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 8 for field id";

          throw Exception(ostr.str());
        }

        unsigned int flags = 
          (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x20)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x20 for field id";

          throw Exception(ostr.str());
        }

        const char* name = (*result)[0].name;

        if(strcmp(name, "id"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of id for field id";

          throw Exception(ostr.str());
        }

        if(use_columns >= 1)
        {
          return;
        }

        type = (*result)[1].type;

        if(type != 1)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 1 for field rnd_mod";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x20)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x20 for field rnd_mod";

          throw Exception(ostr.str());
        }

        name = (*result)[1].name;

        if(strcmp(name, "rnd_mod"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of rnd_mod for field rnd_mod";

          throw Exception(ostr.str());
        }

        if(use_columns >= 2)
        {
          return;
        }

        type = (*result)[2].type;

        if(type != 1)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 1 for field rnd_mod_from";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x20)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x20 for field rnd_mod_from";

          throw Exception(ostr.str());
        }

        name = (*result)[2].name;

        if(strcmp(name, "rnd_mod_from"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of rnd_mod_from for field rnd_mod_from";

          throw Exception(ostr.str());
        }

        if(use_columns >= 3)
        {
          return;
        }

        type = (*result)[3].type;

        if(type != 1)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 1 for field rnd_mod_to";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[3].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x20)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x20 for field rnd_mod_to";

          throw Exception(ostr.str());
        }

        name = (*result)[3].name;

        if(strcmp(name, "rnd_mod_to"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of rnd_mod_to for field rnd_mod_to";

          throw Exception(ostr.str());
        }

        if(use_columns >= 4)
        {
          return;
        }

        type = (*result)[4].type;

        if(type != 3)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 3 for field group_freq_cap";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[4].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x20)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x20 for field group_freq_cap";

          throw Exception(ostr.str());
        }

        name = (*result)[4].name;

        if(strcmp(name, "group_freq_cap"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of group_freq_cap for field group_freq_cap";

          throw Exception(ostr.str());
        }

        if(use_columns >= 5)
        {
          return;
        }

        type = (*result)[5].type;

        if(type != 3)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 3 for field group_count_cap";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[5].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x20)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x20 for field group_count_cap";

          throw Exception(ostr.str());
        }

        name = (*result)[5].name;

        if(strcmp(name, "group_count_cap"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of group_count_cap for field group_count_cap";

          throw Exception(ostr.str());
        }

        if(use_columns >= 6)
        {
          return;
        }

        type = (*result)[6].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 8 for field query_types";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[6].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x20)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x20 for field query_types";

          throw Exception(ostr.str());
        }

        name = (*result)[6].name;

        if(strcmp(name, "query_types"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of query_types for field query_types";

          throw Exception(ostr.str());
        }

        if(use_columns >= 7)
        {
          return;
        }

        type = (*result)[7].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 8 for field query_type_exclusions";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[7].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x20)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x20 for field query_type_exclusions";

          throw Exception(ostr.str());
        }

        name = (*result)[7].name;

        if(strcmp(name, "query_type_exclusions"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of query_type_exclusions for field query_type_exclusions";

          throw Exception(ostr.str());
        }

        if(use_columns >= 8)
        {
          return;
        }

        type = (*result)[8].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 252 for field page_sources";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[8].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field page_sources";

          throw Exception(ostr.str());
        }

        name = (*result)[8].name;

        if(strcmp(name, "page_sources"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of page_sources for field page_sources";

          throw Exception(ostr.str());
        }

        if(use_columns >= 9)
        {
          return;
        }

        type = (*result)[9].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 252 for field page_source_exclusions";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[9].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field page_source_exclusions";

          throw Exception(ostr.str());
        }

        name = (*result)[9].name;

        if(strcmp(name, "page_source_exclusions"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of page_source_exclusions for field page_source_exclusions";

          throw Exception(ostr.str());
        }

        if(use_columns >= 10)
        {
          return;
        }

        type = (*result)[10].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 252 for field message_sources";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[10].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field message_sources";

          throw Exception(ostr.str());
        }

        name = (*result)[10].name;

        if(strcmp(name, "message_sources"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of message_sources for field message_sources";

          throw Exception(ostr.str());
        }

        if(use_columns >= 11)
        {
          return;
        }

        type = (*result)[11].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 252 for field message_source_exclusions";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[11].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field message_source_exclusions";

          throw Exception(ostr.str());
        }

        name = (*result)[11].name;

        if(strcmp(name, "message_source_exclusions"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of message_source_exclusions for field message_source_exclusions";

          throw Exception(ostr.str());
        }

        if(use_columns >= 12)
        {
          return;
        }

        type = (*result)[12].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 253 for field page_categories";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[12].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field page_categories";

          throw Exception(ostr.str());
        }

        name = (*result)[12].name;

        if(strcmp(name, "page_categories"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of page_categories for field page_categories";

          throw Exception(ostr.str());
        }

        if(use_columns >= 13)
        {
          return;
        }

        type = (*result)[13].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 253 for field page_category_exclusions";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[13].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field page_category_exclusions";

          throw Exception(ostr.str());
        }

        name = (*result)[13].name;

        if(strcmp(name, "page_category_exclusions"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of page_category_exclusions for field page_category_exclusions";

          throw Exception(ostr.str());
        }

        if(use_columns >= 14)
        {
          return;
        }

        type = (*result)[14].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 253 for field message_categories";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[14].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field message_categories";

          throw Exception(ostr.str());
        }

        name = (*result)[14].name;

        if(strcmp(name, "message_categories"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of message_categories for field message_categories";

          throw Exception(ostr.str());
        }

        if(use_columns >= 15)
        {
          return;
        }

        type = (*result)[15].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 253 for field message_category_exclusions";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[15].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field message_category_exclusions";

          throw Exception(ostr.str());
        }

        name = (*result)[15].name;

        if(strcmp(name, "message_category_exclusions"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of message_category_exclusions for field message_category_exclusions";

          throw Exception(ostr.str());
        }

        if(use_columns >= 16)
        {
          return;
        }

        type = (*result)[16].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 253 for field search_engines";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[16].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field search_engines";

          throw Exception(ostr.str());
        }

        name = (*result)[16].name;

        if(strcmp(name, "search_engines"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of search_engines for field search_engines";

          throw Exception(ostr.str());
        }

        if(use_columns >= 17)
        {
          return;
        }

        type = (*result)[17].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 253 for field search_engine_exclusions";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[17].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field search_engine_exclusions";

          throw Exception(ostr.str());
        }

        name = (*result)[17].name;

        if(strcmp(name, "search_engine_exclusions"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of search_engine_exclusions for field search_engine_exclusions";

          throw Exception(ostr.str());
        }

        if(use_columns >= 18)
        {
          return;
        }

        type = (*result)[18].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 253 for field crawlers";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[18].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field crawlers";

          throw Exception(ostr.str());
        }

        name = (*result)[18].name;

        if(strcmp(name, "crawlers"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of crawlers for field crawlers";

          throw Exception(ostr.str());
        }

        if(use_columns >= 19)
        {
          return;
        }

        type = (*result)[19].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 253 for field crawler_exclusions";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[19].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field crawler_exclusions";

          throw Exception(ostr.str());
        }

        name = (*result)[19].name;

        if(strcmp(name, "crawler_exclusions"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of crawler_exclusions for field crawler_exclusions";

          throw Exception(ostr.str());
        }

        if(use_columns >= 20)
        {
          return;
        }

        type = (*result)[20].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 253 for field languages";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[20].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field languages";

          throw Exception(ostr.str());
        }

        name = (*result)[20].name;

        if(strcmp(name, "languages"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of languages for field languages";

          throw Exception(ostr.str());
        }

        if(use_columns >= 21)
        {
          return;
        }

        type = (*result)[21].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 253 for field language_exclusions";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[21].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field language_exclusions";

          throw Exception(ostr.str());
        }

        name = (*result)[21].name;

        if(strcmp(name, "language_exclusions"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of language_exclusions for field language_exclusions";

          throw Exception(ostr.str());
        }

        if(use_columns >= 22)
        {
          return;
        }

        type = (*result)[22].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 253 for field countries";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[22].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field countries";

          throw Exception(ostr.str());
        }

        name = (*result)[22].name;

        if(strcmp(name, "countries"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of countries for field countries";

          throw Exception(ostr.str());
        }

        if(use_columns >= 23)
        {
          return;
        }

        type = (*result)[23].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 253 for field country_exclusions";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[23].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field country_exclusions";

          throw Exception(ostr.str());
        }

        name = (*result)[23].name;

        if(strcmp(name, "country_exclusions"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of country_exclusions for field country_exclusions";

          throw Exception(ostr.str());
        }

        if(use_columns >= 24)
        {
          return;
        }

        type = (*result)[24].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 252 for field ip_masks";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[24].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field ip_masks";

          throw Exception(ostr.str());
        }

        name = (*result)[24].name;

        if(strcmp(name, "ip_masks"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of ip_masks for field ip_masks";

          throw Exception(ostr.str());
        }

        if(use_columns >= 25)
        {
          return;
        }

        type = (*result)[25].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 252 for field ip_mask_exclusions";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[25].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field ip_mask_exclusions";

          throw Exception(ostr.str());
        }

        name = (*result)[25].name;

        if(strcmp(name, "ip_mask_exclusions"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of ip_mask_exclusions for field ip_mask_exclusions";

          throw Exception(ostr.str());
        }

        if(use_columns >= 26)
        {
          return;
        }

        type = (*result)[26].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 253 for field tags";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[26].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field tags";

          throw Exception(ostr.str());
        }

        name = (*result)[26].name;

        if(strcmp(name, "tags"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of tags for field tags";

          throw Exception(ostr.str());
        }

        if(use_columns >= 27)
        {
          return;
        }

        type = (*result)[27].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 253 for field tag_exclusions";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[27].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field tag_exclusions";

          throw Exception(ostr.str());
        }

        name = (*result)[27].name;

        if(strcmp(name, "tag_exclusions"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of tag_exclusions for field tag_exclusions";

          throw Exception(ostr.str());
        }

        if(use_columns >= 28)
        {
          return;
        }

        type = (*result)[28].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 252 for field referers";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[28].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field referers";

          throw Exception(ostr.str());
        }

        name = (*result)[28].name;

        if(strcmp(name, "referers"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of referers for field referers";

          throw Exception(ostr.str());
        }

        if(use_columns >= 29)
        {
          return;
        }

        type = (*result)[29].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 252 for field referer_exclusions";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[29].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field referer_exclusions";

          throw Exception(ostr.str());
        }

        name = (*result)[29].name;

        if(strcmp(name, "referer_exclusions"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of referer_exclusions for field referer_exclusions";

          throw Exception(ostr.str());
        }

        if(use_columns >= 30)
        {
          return;
        }

        type = (*result)[30].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 253 for field content_languages";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[30].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field content_languages";

          throw Exception(ostr.str());
        }

        name = (*result)[30].name;

        if(strcmp(name, "content_languages"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of content_languages for field content_languages";

          throw Exception(ostr.str());
        }

        if(use_columns >= 31)
        {
          return;
        }

        type = (*result)[31].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected type " << type
               << " instead of 253 for field content_language_exclusions";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[31].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field content_language_exclusions";

          throw Exception(ostr.str());
        }

        name = (*result)[31].name;

        if(strcmp(name, "content_language_exclusions"))
        {
          std::ostringstream ostr;
          ostr << "Condition::Condition: unexpected name " << name
               << " instead of content_language_exclusions for field content_language_exclusions";

          throw Exception(ostr.str());
        }

      }

      inline
      El::MySQL::UnsignedLongLong
      Condition::id() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::id: row_ is 0");
        }

        if(0 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::id: unexpected index 0 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[0] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[0], lengths[0]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "Condition::id: failed to convert 'id' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::UnsignedChar
      Condition::rnd_mod() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::rnd_mod: row_ is 0");
        }

        if(1 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::rnd_mod: unexpected index 1 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned short value = 0;
        bool is_null = row_[1] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[1], lengths[1]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "Condition::rnd_mod: failed to convert 'rnd_mod' field data"
              " to unsigned short";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedChar(is_null, value);
      }

      inline
      El::MySQL::UnsignedChar
      Condition::rnd_mod_from() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::rnd_mod_from: row_ is 0");
        }

        if(2 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::rnd_mod_from: unexpected index 2 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned short value = 0;
        bool is_null = row_[2] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[2], lengths[2]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "Condition::rnd_mod_from: failed to convert 'rnd_mod_from' field data"
              " to unsigned short";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedChar(is_null, value);
      }

      inline
      El::MySQL::UnsignedChar
      Condition::rnd_mod_to() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::rnd_mod_to: row_ is 0");
        }

        if(3 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::rnd_mod_to: unexpected index 3 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned short value = 0;
        bool is_null = row_[3] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[3], lengths[3]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "Condition::rnd_mod_to: failed to convert 'rnd_mod_to' field data"
              " to unsigned short";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedChar(is_null, value);
      }

      inline
      El::MySQL::UnsignedLong
      Condition::group_freq_cap() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::group_freq_cap: row_ is 0");
        }

        if(4 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::group_freq_cap: unexpected index 4 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long value = 0;
        bool is_null = row_[4] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[4], lengths[4]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "Condition::group_freq_cap: failed to convert 'group_freq_cap' field data"
              " to unsigned long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLong(is_null, value);
      }

      inline
      El::MySQL::UnsignedLong
      Condition::group_count_cap() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::group_count_cap: row_ is 0");
        }

        if(5 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::group_count_cap: unexpected index 5 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long value = 0;
        bool is_null = row_[5] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[5], lengths[5]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "Condition::group_count_cap: failed to convert 'group_count_cap' field data"
              " to unsigned long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLong(is_null, value);
      }

      inline
      El::MySQL::UnsignedLongLong
      Condition::query_types() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::query_types: row_ is 0");
        }

        if(6 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::query_types: unexpected index 6 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[6] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[6], lengths[6]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "Condition::query_types: failed to convert 'query_types' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::UnsignedLongLong
      Condition::query_type_exclusions() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::query_type_exclusions: row_ is 0");
        }

        if(7 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::query_type_exclusions: unexpected index 7 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[7] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[7], lengths[7]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "Condition::query_type_exclusions: failed to convert 'query_type_exclusions' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::String
      Condition::page_sources() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::page_sources: row_ is 0");
        }

        if(8 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::page_sources: unexpected index 8 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[8] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[8], lengths[8]);

        return tmp;
      }

      inline
      El::MySQL::String
      Condition::page_source_exclusions() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::page_source_exclusions: row_ is 0");
        }

        if(9 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::page_source_exclusions: unexpected index 9 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[9] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[9], lengths[9]);

        return tmp;
      }

      inline
      El::MySQL::String
      Condition::message_sources() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::message_sources: row_ is 0");
        }

        if(10 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::message_sources: unexpected index 10 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[10] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[10], lengths[10]);

        return tmp;
      }

      inline
      El::MySQL::String
      Condition::message_source_exclusions() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::message_source_exclusions: row_ is 0");
        }

        if(11 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::message_source_exclusions: unexpected index 11 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[11] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[11], lengths[11]);

        return tmp;
      }

      inline
      El::MySQL::String
      Condition::page_categories() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::page_categories: row_ is 0");
        }

        if(12 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::page_categories: unexpected index 12 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[12] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[12], lengths[12]);

        return tmp;
      }

      inline
      El::MySQL::String
      Condition::page_category_exclusions() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::page_category_exclusions: row_ is 0");
        }

        if(13 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::page_category_exclusions: unexpected index 13 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[13] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[13], lengths[13]);

        return tmp;
      }

      inline
      El::MySQL::String
      Condition::message_categories() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::message_categories: row_ is 0");
        }

        if(14 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::message_categories: unexpected index 14 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[14] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[14], lengths[14]);

        return tmp;
      }

      inline
      El::MySQL::String
      Condition::message_category_exclusions() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::message_category_exclusions: row_ is 0");
        }

        if(15 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::message_category_exclusions: unexpected index 15 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[15] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[15], lengths[15]);

        return tmp;
      }

      inline
      El::MySQL::String
      Condition::search_engines() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::search_engines: row_ is 0");
        }

        if(16 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::search_engines: unexpected index 16 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[16] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[16], lengths[16]);

        return tmp;
      }

      inline
      El::MySQL::String
      Condition::search_engine_exclusions() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::search_engine_exclusions: row_ is 0");
        }

        if(17 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::search_engine_exclusions: unexpected index 17 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[17] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[17], lengths[17]);

        return tmp;
      }

      inline
      El::MySQL::String
      Condition::crawlers() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::crawlers: row_ is 0");
        }

        if(18 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::crawlers: unexpected index 18 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[18] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[18], lengths[18]);

        return tmp;
      }

      inline
      El::MySQL::String
      Condition::crawler_exclusions() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::crawler_exclusions: row_ is 0");
        }

        if(19 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::crawler_exclusions: unexpected index 19 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[19] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[19], lengths[19]);

        return tmp;
      }

      inline
      El::MySQL::String
      Condition::languages() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::languages: row_ is 0");
        }

        if(20 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::languages: unexpected index 20 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[20] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[20], lengths[20]);

        return tmp;
      }

      inline
      El::MySQL::String
      Condition::language_exclusions() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::language_exclusions: row_ is 0");
        }

        if(21 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::language_exclusions: unexpected index 21 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[21] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[21], lengths[21]);

        return tmp;
      }

      inline
      El::MySQL::String
      Condition::countries() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::countries: row_ is 0");
        }

        if(22 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::countries: unexpected index 22 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[22] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[22], lengths[22]);

        return tmp;
      }

      inline
      El::MySQL::String
      Condition::country_exclusions() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::country_exclusions: row_ is 0");
        }

        if(23 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::country_exclusions: unexpected index 23 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[23] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[23], lengths[23]);

        return tmp;
      }

      inline
      El::MySQL::String
      Condition::ip_masks() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::ip_masks: row_ is 0");
        }

        if(24 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::ip_masks: unexpected index 24 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[24] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[24], lengths[24]);

        return tmp;
      }

      inline
      El::MySQL::String
      Condition::ip_mask_exclusions() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::ip_mask_exclusions: row_ is 0");
        }

        if(25 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::ip_mask_exclusions: unexpected index 25 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[25] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[25], lengths[25]);

        return tmp;
      }

      inline
      El::MySQL::String
      Condition::tags() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::tags: row_ is 0");
        }

        if(26 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::tags: unexpected index 26 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[26] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[26], lengths[26]);

        return tmp;
      }

      inline
      El::MySQL::String
      Condition::tag_exclusions() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::tag_exclusions: row_ is 0");
        }

        if(27 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::tag_exclusions: unexpected index 27 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[27] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[27], lengths[27]);

        return tmp;
      }

      inline
      El::MySQL::String
      Condition::referers() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::referers: row_ is 0");
        }

        if(28 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::referers: unexpected index 28 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[28] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[28], lengths[28]);

        return tmp;
      }

      inline
      El::MySQL::String
      Condition::referer_exclusions() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::referer_exclusions: row_ is 0");
        }

        if(29 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::referer_exclusions: unexpected index 29 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[29] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[29], lengths[29]);

        return tmp;
      }

      inline
      El::MySQL::String
      Condition::content_languages() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::content_languages: row_ is 0");
        }

        if(30 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::content_languages: unexpected index 30 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[30] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[30], lengths[30]);

        return tmp;
      }

      inline
      El::MySQL::String
      Condition::content_language_exclusions() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Condition::content_language_exclusions: row_ is 0");
        }

        if(31 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Condition::content_language_exclusions: unexpected index 31 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[31] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[31], lengths[31]);

        return tmp;
      }

    }
  }
}

#endif // _NEWSGATE_AD_DB_ADSELECTOR__1784554767_
