/*
 * product   : NewsGate - news search WEB server
 * copyright : Copyright (c) 2005-2016 Karen Arutyunov
 * licenses  : CC BY-NC-SA 3.0; see accompanying LICENSE file
 *             Commercial; contact karen.arutyunov@gmail.com
 */

// Copyright (C) 2005-2008 Karen Arutyunov
//
// This program was generated by MySQL Class Generating Compiler
// MySQLClassGen (TM)
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA

#ifndef _NEWSGATE_MODERATION_CATEGORY_CATEGORYUPDATENUM__1784554767_
#define _NEWSGATE_MODERATION_CATEGORY_CATEGORYUPDATENUM__1784554767_

#include <limits.h>

#include <string>
#include <sstream>

#include <El/Exception.hpp>
#include <El/MySQL/DB.hpp>

namespace NewsGate
{
  namespace Moderation
  {
    namespace Category
    {
//
// CategoryUpdateNum class declaration
//
      class CategoryUpdateNum: public El::MySQL::Row
      {
      public:
        EL_EXCEPTION(Exception, El::MySQL::Exception);
        EL_EXCEPTION(IsNull, Exception);

      public:
        CategoryUpdateNum(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
          throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong update_num() const
         throw(Exception, El::Exception);

      };

//
// CategoryUpdateNum class definition
//
      inline
      CategoryUpdateNum::CategoryUpdateNum(El::MySQL::Result* result, unsigned long use_columns)
        throw(Exception, El::Exception)
          : Row(result)
      {
        unsigned long num_columns = std::min(use_columns, (unsigned long)1);

        if(result->num_fields() != num_columns)
        {
          std::ostringstream ostr;
          ostr << "CategoryUpdateNum::CategoryUpdateNum: unexpected number of fields "
               << result->num_fields() << " instead of " << num_columns;

          throw Exception(ostr.str());
        }

        if(use_columns >= 0)
        {
          return;
        }

        enum_field_types type = (*result)[0].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "CategoryUpdateNum::CategoryUpdateNum: unexpected type " << type
               << " instead of 8 for field update_num";

          throw Exception(ostr.str());
        }

        unsigned int flags = 
          (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "CategoryUpdateNum::CategoryUpdateNum: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field update_num";

          throw Exception(ostr.str());
        }

        const char* name = (*result)[0].name;

        if(strcmp(name, "update_num"))
        {
          std::ostringstream ostr;
          ostr << "CategoryUpdateNum::CategoryUpdateNum: unexpected name " << name
               << " instead of update_num for field update_num";

          throw Exception(ostr.str());
        }

      }

      inline
      El::MySQL::UnsignedLongLong
      CategoryUpdateNum::update_num() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryUpdateNum::update_num: row_ is 0");
        }

        if(0 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryUpdateNum::update_num: unexpected index 0 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[0] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[0], lengths[0]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "CategoryUpdateNum::update_num: failed to convert 'update_num' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

    }
  }
}

namespace NewsGate
{
  namespace Moderation
  {
    namespace Category
    {
//
// CategoryDesc class declaration
//
      class CategoryDesc: public El::MySQL::Row
      {
      public:
        EL_EXCEPTION(Exception, El::MySQL::Exception);
        EL_EXCEPTION(IsNull, Exception);

      public:
        CategoryDesc(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
          throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong id() const
         throw(Exception, El::Exception);

        El::MySQL::String name() const
         throw(Exception, El::Exception);

        El::MySQL::String status() const
         throw(Exception, El::Exception);

        El::MySQL::String searcheable() const
         throw(Exception, El::Exception);

        El::MySQL::DateTime updated() const
         throw(Exception, El::Exception);

        El::MySQL::DateTime created() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong creator() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong version() const
         throw(Exception, El::Exception);

        El::MySQL::String description() const
         throw(Exception, El::Exception);

      };

//
// CategoryDesc class definition
//
      inline
      CategoryDesc::CategoryDesc(El::MySQL::Result* result, unsigned long use_columns)
        throw(Exception, El::Exception)
          : Row(result)
      {
        unsigned long num_columns = std::min(use_columns, (unsigned long)9);

        if(result->num_fields() != num_columns)
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected number of fields "
               << result->num_fields() << " instead of " << num_columns;

          throw Exception(ostr.str());
        }

        if(use_columns >= 0)
        {
          return;
        }

        enum_field_types type = (*result)[0].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected type " << type
               << " instead of 8 for field id";

          throw Exception(ostr.str());
        }

        unsigned int flags = 
          (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field id";

          throw Exception(ostr.str());
        }

        const char* name = (*result)[0].name;

        if(strcmp(name, "id"))
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected name " << name
               << " instead of id for field id";

          throw Exception(ostr.str());
        }

        if(use_columns >= 1)
        {
          return;
        }

        type = (*result)[1].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected type " << type
               << " instead of 253 for field name";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x81)
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected flags 0x" << std::hex
               << flags << " instead of 0x81 for field name";

          throw Exception(ostr.str());
        }

        name = (*result)[1].name;

        if(strcmp(name, "name"))
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected name " << name
               << " instead of name for field name";

          throw Exception(ostr.str());
        }

        if(use_columns >= 2)
        {
          return;
        }

        type = (*result)[2].type;

        if(type != 254)
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected type " << type
               << " instead of 254 for field status";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field status";

          throw Exception(ostr.str());
        }

        name = (*result)[2].name;

        if(strcmp(name, "status"))
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected name " << name
               << " instead of status for field status";

          throw Exception(ostr.str());
        }

        if(use_columns >= 3)
        {
          return;
        }

        type = (*result)[3].type;

        if(type != 254)
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected type " << type
               << " instead of 254 for field searcheable";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[3].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field searcheable";

          throw Exception(ostr.str());
        }

        name = (*result)[3].name;

        if(strcmp(name, "searcheable"))
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected name " << name
               << " instead of searcheable for field searcheable";

          throw Exception(ostr.str());
        }

        if(use_columns >= 4)
        {
          return;
        }

        type = (*result)[4].type;

        if(type != 7)
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected type " << type
               << " instead of 7 for field updated";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[4].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0xa1)
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected flags 0x" << std::hex
               << flags << " instead of 0xa1 for field updated";

          throw Exception(ostr.str());
        }

        name = (*result)[4].name;

        if(strcmp(name, "updated"))
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected name " << name
               << " instead of updated for field updated";

          throw Exception(ostr.str());
        }

        if(use_columns >= 5)
        {
          return;
        }

        type = (*result)[5].type;

        if(type != 7)
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected type " << type
               << " instead of 7 for field created";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[5].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0xa1)
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected flags 0x" << std::hex
               << flags << " instead of 0xa1 for field created";

          throw Exception(ostr.str());
        }

        name = (*result)[5].name;

        if(strcmp(name, "created"))
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected name " << name
               << " instead of created for field created";

          throw Exception(ostr.str());
        }

        if(use_columns >= 6)
        {
          return;
        }

        type = (*result)[6].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected type " << type
               << " instead of 8 for field creator";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[6].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field creator";

          throw Exception(ostr.str());
        }

        name = (*result)[6].name;

        if(strcmp(name, "creator"))
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected name " << name
               << " instead of creator for field creator";

          throw Exception(ostr.str());
        }

        if(use_columns >= 7)
        {
          return;
        }

        type = (*result)[7].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected type " << type
               << " instead of 8 for field version";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[7].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field version";

          throw Exception(ostr.str());
        }

        name = (*result)[7].name;

        if(strcmp(name, "version"))
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected name " << name
               << " instead of version for field version";

          throw Exception(ostr.str());
        }

        if(use_columns >= 8)
        {
          return;
        }

        type = (*result)[8].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected type " << type
               << " instead of 252 for field description";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[8].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field description";

          throw Exception(ostr.str());
        }

        name = (*result)[8].name;

        if(strcmp(name, "description"))
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::CategoryDesc: unexpected name " << name
               << " instead of description for field description";

          throw Exception(ostr.str());
        }

      }

      inline
      El::MySQL::UnsignedLongLong
      CategoryDesc::id() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryDesc::id: row_ is 0");
        }

        if(0 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::id: unexpected index 0 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[0] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[0], lengths[0]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "CategoryDesc::id: failed to convert 'id' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::String
      CategoryDesc::name() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryDesc::name: row_ is 0");
        }

        if(1 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::name: unexpected index 1 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[1] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[1], lengths[1]);

        return tmp;
      }

      inline
      El::MySQL::String
      CategoryDesc::status() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryDesc::status: row_ is 0");
        }

        if(2 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::status: unexpected index 2 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[2] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[2], lengths[2]);

        return tmp;
      }

      inline
      El::MySQL::String
      CategoryDesc::searcheable() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryDesc::searcheable: row_ is 0");
        }

        if(3 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::searcheable: unexpected index 3 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[3] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[3], lengths[3]);

        return tmp;
      }

      inline
      El::MySQL::DateTime
      CategoryDesc::updated() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryDesc::updated: row_ is 0");
        }

        if(4 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::updated: unexpected index 4 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[4] == 0)
        {
          El::MySQL::DateTime tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::DateTime tmp(false, row_[4], lengths[4]);

        return tmp;
      }

      inline
      El::MySQL::DateTime
      CategoryDesc::created() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryDesc::created: row_ is 0");
        }

        if(5 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::created: unexpected index 5 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[5] == 0)
        {
          El::MySQL::DateTime tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::DateTime tmp(false, row_[5], lengths[5]);

        return tmp;
      }

      inline
      El::MySQL::UnsignedLongLong
      CategoryDesc::creator() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryDesc::creator: row_ is 0");
        }

        if(6 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::creator: unexpected index 6 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[6] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[6], lengths[6]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "CategoryDesc::creator: failed to convert 'creator' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::UnsignedLongLong
      CategoryDesc::version() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryDesc::version: row_ is 0");
        }

        if(7 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::version: unexpected index 7 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[7] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[7], lengths[7]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "CategoryDesc::version: failed to convert 'version' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::String
      CategoryDesc::description() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryDesc::description: row_ is 0");
        }

        if(8 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryDesc::description: unexpected index 8 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[8] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[8], lengths[8]);

        return tmp;
      }

    }
  }
}

namespace NewsGate
{
  namespace Moderation
  {
    namespace Category
    {
//
// CategoryVer class declaration
//
      class CategoryVer: public El::MySQL::Row
      {
      public:
        EL_EXCEPTION(Exception, El::MySQL::Exception);
        EL_EXCEPTION(IsNull, Exception);

      public:
        CategoryVer(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
          throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong version() const
         throw(Exception, El::Exception);

      };

//
// CategoryVer class definition
//
      inline
      CategoryVer::CategoryVer(El::MySQL::Result* result, unsigned long use_columns)
        throw(Exception, El::Exception)
          : Row(result)
      {
        unsigned long num_columns = std::min(use_columns, (unsigned long)1);

        if(result->num_fields() != num_columns)
        {
          std::ostringstream ostr;
          ostr << "CategoryVer::CategoryVer: unexpected number of fields "
               << result->num_fields() << " instead of " << num_columns;

          throw Exception(ostr.str());
        }

        if(use_columns >= 0)
        {
          return;
        }

        enum_field_types type = (*result)[0].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "CategoryVer::CategoryVer: unexpected type " << type
               << " instead of 8 for field version";

          throw Exception(ostr.str());
        }

        unsigned int flags = 
          (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "CategoryVer::CategoryVer: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field version";

          throw Exception(ostr.str());
        }

        const char* name = (*result)[0].name;

        if(strcmp(name, "version"))
        {
          std::ostringstream ostr;
          ostr << "CategoryVer::CategoryVer: unexpected name " << name
               << " instead of version for field version";

          throw Exception(ostr.str());
        }

      }

      inline
      El::MySQL::UnsignedLongLong
      CategoryVer::version() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryVer::version: row_ is 0");
        }

        if(0 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryVer::version: unexpected index 0 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[0] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[0], lengths[0]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "CategoryVer::version: failed to convert 'version' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

    }
  }
}

namespace NewsGate
{
  namespace Moderation
  {
    namespace Category
    {
//
// CategoryExpressionDesc class declaration
//
      class CategoryExpressionDesc: public El::MySQL::Row
      {
      public:
        EL_EXCEPTION(Exception, El::MySQL::Exception);
        EL_EXCEPTION(IsNull, Exception);

      public:
        CategoryExpressionDesc(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
          throw(Exception, El::Exception);

        El::MySQL::String expression() const
         throw(Exception, El::Exception);

        El::MySQL::String description() const
         throw(Exception, El::Exception);

      };

//
// CategoryExpressionDesc class definition
//
      inline
      CategoryExpressionDesc::CategoryExpressionDesc(El::MySQL::Result* result, unsigned long use_columns)
        throw(Exception, El::Exception)
          : Row(result)
      {
        unsigned long num_columns = std::min(use_columns, (unsigned long)2);

        if(result->num_fields() != num_columns)
        {
          std::ostringstream ostr;
          ostr << "CategoryExpressionDesc::CategoryExpressionDesc: unexpected number of fields "
               << result->num_fields() << " instead of " << num_columns;

          throw Exception(ostr.str());
        }

        if(use_columns >= 0)
        {
          return;
        }

        enum_field_types type = (*result)[0].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "CategoryExpressionDesc::CategoryExpressionDesc: unexpected type " << type
               << " instead of 252 for field expression";

          throw Exception(ostr.str());
        }

        unsigned int flags = 
          (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "CategoryExpressionDesc::CategoryExpressionDesc: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field expression";

          throw Exception(ostr.str());
        }

        const char* name = (*result)[0].name;

        if(strcmp(name, "expression"))
        {
          std::ostringstream ostr;
          ostr << "CategoryExpressionDesc::CategoryExpressionDesc: unexpected name " << name
               << " instead of expression for field expression";

          throw Exception(ostr.str());
        }

        if(use_columns >= 1)
        {
          return;
        }

        type = (*result)[1].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "CategoryExpressionDesc::CategoryExpressionDesc: unexpected type " << type
               << " instead of 252 for field description";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "CategoryExpressionDesc::CategoryExpressionDesc: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field description";

          throw Exception(ostr.str());
        }

        name = (*result)[1].name;

        if(strcmp(name, "description"))
        {
          std::ostringstream ostr;
          ostr << "CategoryExpressionDesc::CategoryExpressionDesc: unexpected name " << name
               << " instead of description for field description";

          throw Exception(ostr.str());
        }

      }

      inline
      El::MySQL::String
      CategoryExpressionDesc::expression() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryExpressionDesc::expression: row_ is 0");
        }

        if(0 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryExpressionDesc::expression: unexpected index 0 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[0] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[0], lengths[0]);

        return tmp;
      }

      inline
      El::MySQL::String
      CategoryExpressionDesc::description() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryExpressionDesc::description: row_ is 0");
        }

        if(1 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryExpressionDesc::description: unexpected index 1 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[1] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[1], lengths[1]);

        return tmp;
      }

    }
  }
}

namespace NewsGate
{
  namespace Moderation
  {
    namespace Category
    {
//
// CategoryWordListDesc class declaration
//
      class CategoryWordListDesc: public El::MySQL::Row
      {
      public:
        EL_EXCEPTION(Exception, El::MySQL::Exception);
        EL_EXCEPTION(IsNull, Exception);

      public:
        CategoryWordListDesc(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
          throw(Exception, El::Exception);

        El::MySQL::String name() const
         throw(Exception, El::Exception);

        El::MySQL::String words() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong version() const
         throw(Exception, El::Exception);

        El::MySQL::String description() const
         throw(Exception, El::Exception);

      };

//
// CategoryWordListDesc class definition
//
      inline
      CategoryWordListDesc::CategoryWordListDesc(El::MySQL::Result* result, unsigned long use_columns)
        throw(Exception, El::Exception)
          : Row(result)
      {
        unsigned long num_columns = std::min(use_columns, (unsigned long)4);

        if(result->num_fields() != num_columns)
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListDesc::CategoryWordListDesc: unexpected number of fields "
               << result->num_fields() << " instead of " << num_columns;

          throw Exception(ostr.str());
        }

        if(use_columns >= 0)
        {
          return;
        }

        enum_field_types type = (*result)[0].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListDesc::CategoryWordListDesc: unexpected type " << type
               << " instead of 253 for field name";

          throw Exception(ostr.str());
        }

        unsigned int flags = 
          (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x81)
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListDesc::CategoryWordListDesc: unexpected flags 0x" << std::hex
               << flags << " instead of 0x81 for field name";

          throw Exception(ostr.str());
        }

        const char* name = (*result)[0].name;

        if(strcmp(name, "name"))
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListDesc::CategoryWordListDesc: unexpected name " << name
               << " instead of name for field name";

          throw Exception(ostr.str());
        }

        if(use_columns >= 1)
        {
          return;
        }

        type = (*result)[1].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListDesc::CategoryWordListDesc: unexpected type " << type
               << " instead of 252 for field words";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListDesc::CategoryWordListDesc: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field words";

          throw Exception(ostr.str());
        }

        name = (*result)[1].name;

        if(strcmp(name, "words"))
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListDesc::CategoryWordListDesc: unexpected name " << name
               << " instead of words for field words";

          throw Exception(ostr.str());
        }

        if(use_columns >= 2)
        {
          return;
        }

        type = (*result)[2].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListDesc::CategoryWordListDesc: unexpected type " << type
               << " instead of 8 for field version";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListDesc::CategoryWordListDesc: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field version";

          throw Exception(ostr.str());
        }

        name = (*result)[2].name;

        if(strcmp(name, "version"))
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListDesc::CategoryWordListDesc: unexpected name " << name
               << " instead of version for field version";

          throw Exception(ostr.str());
        }

        if(use_columns >= 3)
        {
          return;
        }

        type = (*result)[3].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListDesc::CategoryWordListDesc: unexpected type " << type
               << " instead of 252 for field description";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[3].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListDesc::CategoryWordListDesc: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field description";

          throw Exception(ostr.str());
        }

        name = (*result)[3].name;

        if(strcmp(name, "description"))
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListDesc::CategoryWordListDesc: unexpected name " << name
               << " instead of description for field description";

          throw Exception(ostr.str());
        }

      }

      inline
      El::MySQL::String
      CategoryWordListDesc::name() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryWordListDesc::name: row_ is 0");
        }

        if(0 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListDesc::name: unexpected index 0 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[0] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[0], lengths[0]);

        return tmp;
      }

      inline
      El::MySQL::String
      CategoryWordListDesc::words() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryWordListDesc::words: row_ is 0");
        }

        if(1 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListDesc::words: unexpected index 1 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[1] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[1], lengths[1]);

        return tmp;
      }

      inline
      El::MySQL::UnsignedLongLong
      CategoryWordListDesc::version() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryWordListDesc::version: row_ is 0");
        }

        if(2 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListDesc::version: unexpected index 2 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[2] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[2], lengths[2]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "CategoryWordListDesc::version: failed to convert 'version' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::String
      CategoryWordListDesc::description() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryWordListDesc::description: row_ is 0");
        }

        if(3 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListDesc::description: unexpected index 3 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[3] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[3], lengths[3]);

        return tmp;
      }

    }
  }
}

namespace NewsGate
{
  namespace Moderation
  {
    namespace Category
    {
//
// CategoryWordListFindingDesc class declaration
//
      class CategoryWordListFindingDesc: public El::MySQL::Row
      {
      public:
        EL_EXCEPTION(Exception, El::MySQL::Exception);
        EL_EXCEPTION(IsNull, Exception);

      public:
        CategoryWordListFindingDesc(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
          throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong category_id() const
         throw(Exception, El::Exception);

        El::MySQL::String name() const
         throw(Exception, El::Exception);

        El::MySQL::String words() const
         throw(Exception, El::Exception);

      };

//
// CategoryWordListFindingDesc class definition
//
      inline
      CategoryWordListFindingDesc::CategoryWordListFindingDesc(El::MySQL::Result* result, unsigned long use_columns)
        throw(Exception, El::Exception)
          : Row(result)
      {
        unsigned long num_columns = std::min(use_columns, (unsigned long)3);

        if(result->num_fields() != num_columns)
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListFindingDesc::CategoryWordListFindingDesc: unexpected number of fields "
               << result->num_fields() << " instead of " << num_columns;

          throw Exception(ostr.str());
        }

        if(use_columns >= 0)
        {
          return;
        }

        enum_field_types type = (*result)[0].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListFindingDesc::CategoryWordListFindingDesc: unexpected type " << type
               << " instead of 8 for field category_id";

          throw Exception(ostr.str());
        }

        unsigned int flags = 
          (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListFindingDesc::CategoryWordListFindingDesc: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field category_id";

          throw Exception(ostr.str());
        }

        const char* name = (*result)[0].name;

        if(strcmp(name, "category_id"))
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListFindingDesc::CategoryWordListFindingDesc: unexpected name " << name
               << " instead of category_id for field category_id";

          throw Exception(ostr.str());
        }

        if(use_columns >= 1)
        {
          return;
        }

        type = (*result)[1].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListFindingDesc::CategoryWordListFindingDesc: unexpected type " << type
               << " instead of 253 for field name";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x81)
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListFindingDesc::CategoryWordListFindingDesc: unexpected flags 0x" << std::hex
               << flags << " instead of 0x81 for field name";

          throw Exception(ostr.str());
        }

        name = (*result)[1].name;

        if(strcmp(name, "name"))
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListFindingDesc::CategoryWordListFindingDesc: unexpected name " << name
               << " instead of name for field name";

          throw Exception(ostr.str());
        }

        if(use_columns >= 2)
        {
          return;
        }

        type = (*result)[2].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListFindingDesc::CategoryWordListFindingDesc: unexpected type " << type
               << " instead of 252 for field words";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x0)
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListFindingDesc::CategoryWordListFindingDesc: unexpected flags 0x" << std::hex
               << flags << " instead of 0x0 for field words";

          throw Exception(ostr.str());
        }

        name = (*result)[2].name;

        if(strcmp(name, "words"))
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListFindingDesc::CategoryWordListFindingDesc: unexpected name " << name
               << " instead of words for field words";

          throw Exception(ostr.str());
        }

      }

      inline
      El::MySQL::UnsignedLongLong
      CategoryWordListFindingDesc::category_id() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryWordListFindingDesc::category_id: row_ is 0");
        }

        if(0 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListFindingDesc::category_id: unexpected index 0 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[0] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[0], lengths[0]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "CategoryWordListFindingDesc::category_id: failed to convert 'category_id' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::String
      CategoryWordListFindingDesc::name() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryWordListFindingDesc::name: row_ is 0");
        }

        if(1 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListFindingDesc::name: unexpected index 1 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[1] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[1], lengths[1]);

        return tmp;
      }

      inline
      El::MySQL::String
      CategoryWordListFindingDesc::words() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryWordListFindingDesc::words: row_ is 0");
        }

        if(2 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListFindingDesc::words: unexpected index 2 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[2] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[2], lengths[2]);

        return tmp;
      }

    }
  }
}

namespace NewsGate
{
  namespace Moderation
  {
    namespace Category
    {
//
// CategoryWordListVer class declaration
//
      class CategoryWordListVer: public El::MySQL::Row
      {
      public:
        EL_EXCEPTION(Exception, El::MySQL::Exception);
        EL_EXCEPTION(IsNull, Exception);

      public:
        CategoryWordListVer(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
          throw(Exception, El::Exception);

        El::MySQL::String name() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong version() const
         throw(Exception, El::Exception);

      };

//
// CategoryWordListVer class definition
//
      inline
      CategoryWordListVer::CategoryWordListVer(El::MySQL::Result* result, unsigned long use_columns)
        throw(Exception, El::Exception)
          : Row(result)
      {
        unsigned long num_columns = std::min(use_columns, (unsigned long)2);

        if(result->num_fields() != num_columns)
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListVer::CategoryWordListVer: unexpected number of fields "
               << result->num_fields() << " instead of " << num_columns;

          throw Exception(ostr.str());
        }

        if(use_columns >= 0)
        {
          return;
        }

        enum_field_types type = (*result)[0].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListVer::CategoryWordListVer: unexpected type " << type
               << " instead of 253 for field name";

          throw Exception(ostr.str());
        }

        unsigned int flags = 
          (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x81)
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListVer::CategoryWordListVer: unexpected flags 0x" << std::hex
               << flags << " instead of 0x81 for field name";

          throw Exception(ostr.str());
        }

        const char* name = (*result)[0].name;

        if(strcmp(name, "name"))
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListVer::CategoryWordListVer: unexpected name " << name
               << " instead of name for field name";

          throw Exception(ostr.str());
        }

        if(use_columns >= 1)
        {
          return;
        }

        type = (*result)[1].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListVer::CategoryWordListVer: unexpected type " << type
               << " instead of 8 for field version";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListVer::CategoryWordListVer: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field version";

          throw Exception(ostr.str());
        }

        name = (*result)[1].name;

        if(strcmp(name, "version"))
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListVer::CategoryWordListVer: unexpected name " << name
               << " instead of version for field version";

          throw Exception(ostr.str());
        }

      }

      inline
      El::MySQL::String
      CategoryWordListVer::name() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryWordListVer::name: row_ is 0");
        }

        if(0 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListVer::name: unexpected index 0 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[0] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[0], lengths[0]);

        return tmp;
      }

      inline
      El::MySQL::UnsignedLongLong
      CategoryWordListVer::version() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryWordListVer::version: row_ is 0");
        }

        if(1 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryWordListVer::version: unexpected index 1 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[1] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[1], lengths[1]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "CategoryWordListVer::version: failed to convert 'version' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

    }
  }
}

namespace NewsGate
{
  namespace Moderation
  {
    namespace Category
    {
//
// CategoryLocaleDesc class declaration
//
      class CategoryLocaleDesc: public El::MySQL::Row
      {
      public:
        EL_EXCEPTION(Exception, El::MySQL::Exception);
        EL_EXCEPTION(IsNull, Exception);

      public:
        CategoryLocaleDesc(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
          throw(Exception, El::Exception);

        El::MySQL::UnsignedShort lang() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedShort country() const
         throw(Exception, El::Exception);

        El::MySQL::String name() const
         throw(Exception, El::Exception);

        El::MySQL::String title() const
         throw(Exception, El::Exception);

        El::MySQL::String short_title() const
         throw(Exception, El::Exception);

        El::MySQL::String description() const
         throw(Exception, El::Exception);

        El::MySQL::String keywords() const
         throw(Exception, El::Exception);

      };

//
// CategoryLocaleDesc class definition
//
      inline
      CategoryLocaleDesc::CategoryLocaleDesc(El::MySQL::Result* result, unsigned long use_columns)
        throw(Exception, El::Exception)
          : Row(result)
      {
        unsigned long num_columns = std::min(use_columns, (unsigned long)7);

        if(result->num_fields() != num_columns)
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::CategoryLocaleDesc: unexpected number of fields "
               << result->num_fields() << " instead of " << num_columns;

          throw Exception(ostr.str());
        }

        if(use_columns >= 0)
        {
          return;
        }

        enum_field_types type = (*result)[0].type;

        if(type != 2)
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::CategoryLocaleDesc: unexpected type " << type
               << " instead of 2 for field lang";

          throw Exception(ostr.str());
        }

        unsigned int flags = 
          (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::CategoryLocaleDesc: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field lang";

          throw Exception(ostr.str());
        }

        const char* name = (*result)[0].name;

        if(strcmp(name, "lang"))
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::CategoryLocaleDesc: unexpected name " << name
               << " instead of lang for field lang";

          throw Exception(ostr.str());
        }

        if(use_columns >= 1)
        {
          return;
        }

        type = (*result)[1].type;

        if(type != 2)
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::CategoryLocaleDesc: unexpected type " << type
               << " instead of 2 for field country";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::CategoryLocaleDesc: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field country";

          throw Exception(ostr.str());
        }

        name = (*result)[1].name;

        if(strcmp(name, "country"))
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::CategoryLocaleDesc: unexpected name " << name
               << " instead of country for field country";

          throw Exception(ostr.str());
        }

        if(use_columns >= 2)
        {
          return;
        }

        type = (*result)[2].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::CategoryLocaleDesc: unexpected type " << type
               << " instead of 253 for field name";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x81)
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::CategoryLocaleDesc: unexpected flags 0x" << std::hex
               << flags << " instead of 0x81 for field name";

          throw Exception(ostr.str());
        }

        name = (*result)[2].name;

        if(strcmp(name, "name"))
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::CategoryLocaleDesc: unexpected name " << name
               << " instead of name for field name";

          throw Exception(ostr.str());
        }

        if(use_columns >= 3)
        {
          return;
        }

        type = (*result)[3].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::CategoryLocaleDesc: unexpected type " << type
               << " instead of 252 for field title";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[3].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x81)
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::CategoryLocaleDesc: unexpected flags 0x" << std::hex
               << flags << " instead of 0x81 for field title";

          throw Exception(ostr.str());
        }

        name = (*result)[3].name;

        if(strcmp(name, "title"))
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::CategoryLocaleDesc: unexpected name " << name
               << " instead of title for field title";

          throw Exception(ostr.str());
        }

        if(use_columns >= 4)
        {
          return;
        }

        type = (*result)[4].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::CategoryLocaleDesc: unexpected type " << type
               << " instead of 252 for field short_title";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[4].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x81)
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::CategoryLocaleDesc: unexpected flags 0x" << std::hex
               << flags << " instead of 0x81 for field short_title";

          throw Exception(ostr.str());
        }

        name = (*result)[4].name;

        if(strcmp(name, "short_title"))
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::CategoryLocaleDesc: unexpected name " << name
               << " instead of short_title for field short_title";

          throw Exception(ostr.str());
        }

        if(use_columns >= 5)
        {
          return;
        }

        type = (*result)[5].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::CategoryLocaleDesc: unexpected type " << type
               << " instead of 252 for field description";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[5].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x81)
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::CategoryLocaleDesc: unexpected flags 0x" << std::hex
               << flags << " instead of 0x81 for field description";

          throw Exception(ostr.str());
        }

        name = (*result)[5].name;

        if(strcmp(name, "description"))
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::CategoryLocaleDesc: unexpected name " << name
               << " instead of description for field description";

          throw Exception(ostr.str());
        }

        if(use_columns >= 6)
        {
          return;
        }

        type = (*result)[6].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::CategoryLocaleDesc: unexpected type " << type
               << " instead of 252 for field keywords";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[6].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x81)
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::CategoryLocaleDesc: unexpected flags 0x" << std::hex
               << flags << " instead of 0x81 for field keywords";

          throw Exception(ostr.str());
        }

        name = (*result)[6].name;

        if(strcmp(name, "keywords"))
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::CategoryLocaleDesc: unexpected name " << name
               << " instead of keywords for field keywords";

          throw Exception(ostr.str());
        }

      }

      inline
      El::MySQL::UnsignedShort
      CategoryLocaleDesc::lang() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryLocaleDesc::lang: row_ is 0");
        }

        if(0 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::lang: unexpected index 0 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned short value = 0;
        bool is_null = row_[0] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[0], lengths[0]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "CategoryLocaleDesc::lang: failed to convert 'lang' field data"
              " to unsigned short";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedShort(is_null, value);
      }

      inline
      El::MySQL::UnsignedShort
      CategoryLocaleDesc::country() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryLocaleDesc::country: row_ is 0");
        }

        if(1 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::country: unexpected index 1 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned short value = 0;
        bool is_null = row_[1] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[1], lengths[1]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "CategoryLocaleDesc::country: failed to convert 'country' field data"
              " to unsigned short";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedShort(is_null, value);
      }

      inline
      El::MySQL::String
      CategoryLocaleDesc::name() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryLocaleDesc::name: row_ is 0");
        }

        if(2 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::name: unexpected index 2 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[2] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[2], lengths[2]);

        return tmp;
      }

      inline
      El::MySQL::String
      CategoryLocaleDesc::title() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryLocaleDesc::title: row_ is 0");
        }

        if(3 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::title: unexpected index 3 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[3] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[3], lengths[3]);

        return tmp;
      }

      inline
      El::MySQL::String
      CategoryLocaleDesc::short_title() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryLocaleDesc::short_title: row_ is 0");
        }

        if(4 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::short_title: unexpected index 4 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[4] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[4], lengths[4]);

        return tmp;
      }

      inline
      El::MySQL::String
      CategoryLocaleDesc::description() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryLocaleDesc::description: row_ is 0");
        }

        if(5 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::description: unexpected index 5 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[5] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[5], lengths[5]);

        return tmp;
      }

      inline
      El::MySQL::String
      CategoryLocaleDesc::keywords() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryLocaleDesc::keywords: row_ is 0");
        }

        if(6 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryLocaleDesc::keywords: unexpected index 6 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[6] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[6], lengths[6]);

        return tmp;
      }

    }
  }
}

namespace NewsGate
{
  namespace Moderation
  {
    namespace Category
    {
//
// CategoryChild class declaration
//
      class CategoryChild: public El::MySQL::Row
      {
      public:
        EL_EXCEPTION(Exception, El::MySQL::Exception);
        EL_EXCEPTION(IsNull, Exception);

      public:
        CategoryChild(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
          throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong id() const
         throw(Exception, El::Exception);

        El::MySQL::String name() const
         throw(Exception, El::Exception);

      };

//
// CategoryChild class definition
//
      inline
      CategoryChild::CategoryChild(El::MySQL::Result* result, unsigned long use_columns)
        throw(Exception, El::Exception)
          : Row(result)
      {
        unsigned long num_columns = std::min(use_columns, (unsigned long)2);

        if(result->num_fields() != num_columns)
        {
          std::ostringstream ostr;
          ostr << "CategoryChild::CategoryChild: unexpected number of fields "
               << result->num_fields() << " instead of " << num_columns;

          throw Exception(ostr.str());
        }

        if(use_columns >= 0)
        {
          return;
        }

        enum_field_types type = (*result)[0].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "CategoryChild::CategoryChild: unexpected type " << type
               << " instead of 8 for field id";

          throw Exception(ostr.str());
        }

        unsigned int flags = 
          (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "CategoryChild::CategoryChild: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field id";

          throw Exception(ostr.str());
        }

        const char* name = (*result)[0].name;

        if(strcmp(name, "id"))
        {
          std::ostringstream ostr;
          ostr << "CategoryChild::CategoryChild: unexpected name " << name
               << " instead of id for field id";

          throw Exception(ostr.str());
        }

        if(use_columns >= 1)
        {
          return;
        }

        type = (*result)[1].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "CategoryChild::CategoryChild: unexpected type " << type
               << " instead of 253 for field name";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x80)
        {
          std::ostringstream ostr;
          ostr << "CategoryChild::CategoryChild: unexpected flags 0x" << std::hex
               << flags << " instead of 0x80 for field name";

          throw Exception(ostr.str());
        }

        name = (*result)[1].name;

        if(strcmp(name, "name"))
        {
          std::ostringstream ostr;
          ostr << "CategoryChild::CategoryChild: unexpected name " << name
               << " instead of name for field name";

          throw Exception(ostr.str());
        }

      }

      inline
      El::MySQL::UnsignedLongLong
      CategoryChild::id() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryChild::id: row_ is 0");
        }

        if(0 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryChild::id: unexpected index 0 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[0] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[0], lengths[0]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "CategoryChild::id: failed to convert 'id' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::String
      CategoryChild::name() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryChild::name: row_ is 0");
        }

        if(1 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryChild::name: unexpected index 1 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[1] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[1], lengths[1]);

        return tmp;
      }

    }
  }
}

namespace NewsGate
{
  namespace Moderation
  {
    namespace Category
    {
//
// CategoryMessage class declaration
//
      class CategoryMessage: public El::MySQL::Row
      {
      public:
        EL_EXCEPTION(Exception, El::MySQL::Exception);
        EL_EXCEPTION(IsNull, Exception);

      public:
        CategoryMessage(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
          throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong message_id() const
         throw(Exception, El::Exception);

        El::MySQL::String relation() const
         throw(Exception, El::Exception);

      };

//
// CategoryMessage class definition
//
      inline
      CategoryMessage::CategoryMessage(El::MySQL::Result* result, unsigned long use_columns)
        throw(Exception, El::Exception)
          : Row(result)
      {
        unsigned long num_columns = std::min(use_columns, (unsigned long)2);

        if(result->num_fields() != num_columns)
        {
          std::ostringstream ostr;
          ostr << "CategoryMessage::CategoryMessage: unexpected number of fields "
               << result->num_fields() << " instead of " << num_columns;

          throw Exception(ostr.str());
        }

        if(use_columns >= 0)
        {
          return;
        }

        enum_field_types type = (*result)[0].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "CategoryMessage::CategoryMessage: unexpected type " << type
               << " instead of 8 for field message_id";

          throw Exception(ostr.str());
        }

        unsigned int flags = 
          (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "CategoryMessage::CategoryMessage: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field message_id";

          throw Exception(ostr.str());
        }

        const char* name = (*result)[0].name;

        if(strcmp(name, "message_id"))
        {
          std::ostringstream ostr;
          ostr << "CategoryMessage::CategoryMessage: unexpected name " << name
               << " instead of message_id for field message_id";

          throw Exception(ostr.str());
        }

        if(use_columns >= 1)
        {
          return;
        }

        type = (*result)[1].type;

        if(type != 254)
        {
          std::ostringstream ostr;
          ostr << "CategoryMessage::CategoryMessage: unexpected type " << type
               << " instead of 254 for field relation";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "CategoryMessage::CategoryMessage: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field relation";

          throw Exception(ostr.str());
        }

        name = (*result)[1].name;

        if(strcmp(name, "relation"))
        {
          std::ostringstream ostr;
          ostr << "CategoryMessage::CategoryMessage: unexpected name " << name
               << " instead of relation for field relation";

          throw Exception(ostr.str());
        }

      }

      inline
      El::MySQL::UnsignedLongLong
      CategoryMessage::message_id() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryMessage::message_id: row_ is 0");
        }

        if(0 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryMessage::message_id: unexpected index 0 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[0] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[0], lengths[0]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "CategoryMessage::message_id: failed to convert 'message_id' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::String
      CategoryMessage::relation() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CategoryMessage::relation: row_ is 0");
        }

        if(1 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CategoryMessage::relation: unexpected index 1 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[1] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[1], lengths[1]);

        return tmp;
      }

    }
  }
}

#endif // _NEWSGATE_MODERATION_CATEGORY_CATEGORYUPDATENUM__1784554767_
