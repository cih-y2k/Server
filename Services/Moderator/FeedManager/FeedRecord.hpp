/*
 * product   : NewsGate - news search WEB server
 * copyright : Copyright (c) 2005-2016 Karen Arutyunov
 * licenses  : CC BY-NC-SA 3.0; see accompanying LICENSE file
 *             Commercial; contact karen.arutyunov@gmail.com
 */

// Copyright (C) 2005-2008 Karen Arutyunov
//
// This program was generated by MySQL Class Generating Compiler
// MySQLClassGen (TM)
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA

#ifndef _NEWSGATE_MODERATION_FEEDTYPERECORD__1784554767_
#define _NEWSGATE_MODERATION_FEEDTYPERECORD__1784554767_

#include <limits.h>

#include <string>
#include <sstream>

#include <El/Exception.hpp>
#include <El/MySQL/DB.hpp>

namespace NewsGate
{
  namespace Moderation
  {
//
// FeedTypeRecord class declaration
//
    class FeedTypeRecord: public El::MySQL::Row
    {
    public:
      EL_EXCEPTION(Exception, El::MySQL::Exception);
      EL_EXCEPTION(IsNull, Exception);

    public:
      FeedTypeRecord(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
        throw(Exception, El::Exception);

      El::MySQL::UnsignedShort type() const
       throw(Exception, El::Exception);

    };

//
// FeedTypeRecord class definition
//
    inline
    FeedTypeRecord::FeedTypeRecord(El::MySQL::Result* result, unsigned long use_columns)
      throw(Exception, El::Exception)
        : Row(result)
    {
      unsigned long num_columns = std::min(use_columns, (unsigned long)1);

      if(result->num_fields() != num_columns)
      {
        std::ostringstream ostr;
        ostr << "FeedTypeRecord::FeedTypeRecord: unexpected number of fields "
             << result->num_fields() << " instead of " << num_columns;

        throw Exception(ostr.str());
      }

      if(use_columns >= 0)
      {
        return;
      }

      enum_field_types type = (*result)[0].type;

      if(type != 2)
      {
        std::ostringstream ostr;
        ostr << "FeedTypeRecord::FeedTypeRecord: unexpected type " << type
             << " instead of 2 for field type";

        throw Exception(ostr.str());
      }

      unsigned int flags = 
        (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

      if(flags != 0x21)
      {
        std::ostringstream ostr;
        ostr << "FeedTypeRecord::FeedTypeRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x21 for field type";

        throw Exception(ostr.str());
      }

      const char* name = (*result)[0].name;

      if(strcmp(name, "type"))
      {
        std::ostringstream ostr;
        ostr << "FeedTypeRecord::FeedTypeRecord: unexpected name " << name
             << " instead of type for field type";

        throw Exception(ostr.str());
      }

    }

    inline
    El::MySQL::UnsignedShort
    FeedTypeRecord::type() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedTypeRecord::type: row_ is 0");
      }

      if(0 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedTypeRecord::type: unexpected index 0 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      unsigned short value = 0;
      bool is_null = row_[0] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[0], lengths[0]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedTypeRecord::type: failed to convert 'type' field data"
            " to unsigned short";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::UnsignedShort(is_null, value);
    }

  }
}

namespace NewsGate
{
  namespace Moderation
  {
//
// FeedUpdateNum class declaration
//
    class FeedUpdateNum: public El::MySQL::Row
    {
    public:
      EL_EXCEPTION(Exception, El::MySQL::Exception);
      EL_EXCEPTION(IsNull, Exception);

    public:
      FeedUpdateNum(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
        throw(Exception, El::Exception);

      El::MySQL::UnsignedLongLong update_num() const
       throw(Exception, El::Exception);

    };

//
// FeedUpdateNum class definition
//
    inline
    FeedUpdateNum::FeedUpdateNum(El::MySQL::Result* result, unsigned long use_columns)
      throw(Exception, El::Exception)
        : Row(result)
    {
      unsigned long num_columns = std::min(use_columns, (unsigned long)1);

      if(result->num_fields() != num_columns)
      {
        std::ostringstream ostr;
        ostr << "FeedUpdateNum::FeedUpdateNum: unexpected number of fields "
             << result->num_fields() << " instead of " << num_columns;

        throw Exception(ostr.str());
      }

      if(use_columns >= 0)
      {
        return;
      }

      enum_field_types type = (*result)[0].type;

      if(type != 8)
      {
        std::ostringstream ostr;
        ostr << "FeedUpdateNum::FeedUpdateNum: unexpected type " << type
             << " instead of 8 for field update_num";

        throw Exception(ostr.str());
      }

      unsigned int flags = 
        (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

      if(flags != 0x21)
      {
        std::ostringstream ostr;
        ostr << "FeedUpdateNum::FeedUpdateNum: unexpected flags 0x" << std::hex
             << flags << " instead of 0x21 for field update_num";

        throw Exception(ostr.str());
      }

      const char* name = (*result)[0].name;

      if(strcmp(name, "update_num"))
      {
        std::ostringstream ostr;
        ostr << "FeedUpdateNum::FeedUpdateNum: unexpected name " << name
             << " instead of update_num for field update_num";

        throw Exception(ostr.str());
      }

    }

    inline
    El::MySQL::UnsignedLongLong
    FeedUpdateNum::update_num() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedUpdateNum::update_num: row_ is 0");
      }

      if(0 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedUpdateNum::update_num: unexpected index 0 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      unsigned long long value = 0;
      bool is_null = row_[0] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[0], lengths[0]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedUpdateNum::update_num: failed to convert 'update_num' field data"
            " to unsigned long long";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::UnsignedLongLong(is_null, value);
    }

  }
}

namespace NewsGate
{
  namespace Moderation
  {
//
// FeedRecord class declaration
//
    class FeedRecord: public El::MySQL::Row
    {
    public:
      EL_EXCEPTION(Exception, El::MySQL::Exception);
      EL_EXCEPTION(IsNull, Exception);

    public:
      FeedRecord(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
        throw(Exception, El::Exception);

      El::MySQL::UnsignedLongLong id() const
       throw(Exception, El::Exception);

      El::MySQL::UnsignedShort type() const
       throw(Exception, El::Exception);

      El::MySQL::String url() const
       throw(Exception, El::Exception);

      El::MySQL::String encoding() const
       throw(Exception, El::Exception);

      El::MySQL::UnsignedShort space() const
       throw(Exception, El::Exception);

      El::MySQL::UnsignedShort lang() const
       throw(Exception, El::Exception);

      El::MySQL::UnsignedShort country() const
       throw(Exception, El::Exception);

      El::MySQL::String status() const
       throw(Exception, El::Exception);

      El::MySQL::UnsignedLongLong creator() const
       throw(Exception, El::Exception);

      El::MySQL::String creator_type() const
       throw(Exception, El::Exception);

      El::MySQL::String keywords() const
       throw(Exception, El::Exception);

      El::MySQL::String adjustment_script() const
       throw(Exception, El::Exception);

      El::MySQL::String comment() const
       throw(Exception, El::Exception);

      El::MySQL::DateTime created() const
       throw(Exception, El::Exception);

      El::MySQL::DateTime updated() const
       throw(Exception, El::Exception);

      El::MySQL::String channel_title() const
       throw(Exception, El::Exception);

      El::MySQL::String channel_description() const
       throw(Exception, El::Exception);

      El::MySQL::String channel_html_link() const
       throw(Exception, El::Exception);

      El::MySQL::UnsignedShort channel_lang() const
       throw(Exception, El::Exception);

      El::MySQL::UnsignedShort channel_country() const
       throw(Exception, El::Exception);

      El::MySQL::UnsignedShort channel_ttl() const
       throw(Exception, El::Exception);

      El::MySQL::DateTime channel_last_build_date() const
       throw(Exception, El::Exception);

      El::MySQL::DateTime last_request_date() const
       throw(Exception, El::Exception);

      El::MySQL::String last_modified_hdr() const
       throw(Exception, El::Exception);

      El::MySQL::String etag_hdr() const
       throw(Exception, El::Exception);

      El::MySQL::LongLong content_length_hdr() const
       throw(Exception, El::Exception);

      El::MySQL::UnsignedLong entropy() const
       throw(Exception, El::Exception);

      El::MySQL::DateTime entropy_updated_date() const
       throw(Exception, El::Exception);

      El::MySQL::UnsignedLong size() const
       throw(Exception, El::Exception);

      El::MySQL::Char single_chunked() const
       throw(Exception, El::Exception);

      El::MySQL::LongLong first_chunk_size() const
       throw(Exception, El::Exception);

      El::MySQL::Long heuristics_counter() const
       throw(Exception, El::Exception);

      El::MySQL::Double requests() const
       throw(Exception, El::Exception);

      El::MySQL::Double failed() const
       throw(Exception, El::Exception);

      El::MySQL::Double unchanged() const
       throw(Exception, El::Exception);

      El::MySQL::Double not_modified() const
       throw(Exception, El::Exception);

      El::MySQL::Double presumably_unchanged() const
       throw(Exception, El::Exception);

      El::MySQL::Double has_changes() const
       throw(Exception, El::Exception);

      El::MySQL::Double wasted() const
       throw(Exception, El::Exception);

      El::MySQL::Double outbound() const
       throw(Exception, El::Exception);

      El::MySQL::Double inbound() const
       throw(Exception, El::Exception);

      El::MySQL::Double requests_duration() const
       throw(Exception, El::Exception);

      El::MySQL::Double messages() const
       throw(Exception, El::Exception);

      El::MySQL::Double messages_size() const
       throw(Exception, El::Exception);

      El::MySQL::Double messages_delay() const
       throw(Exception, El::Exception);

      El::MySQL::UnsignedLongLong max_message_delay() const
       throw(Exception, El::Exception);

      El::MySQL::Double msg_impressions() const
       throw(Exception, El::Exception);

      El::MySQL::Double msg_clicks() const
       throw(Exception, El::Exception);

      El::MySQL::Double msg_ctr() const
       throw(Exception, El::Exception);

    };

//
// FeedRecord class definition
//
    inline
    FeedRecord::FeedRecord(El::MySQL::Result* result, unsigned long use_columns)
      throw(Exception, El::Exception)
        : Row(result)
    {
      unsigned long num_columns = std::min(use_columns, (unsigned long)49);

      if(result->num_fields() != num_columns)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected number of fields "
             << result->num_fields() << " instead of " << num_columns;

        throw Exception(ostr.str());
      }

      if(use_columns >= 0)
      {
        return;
      }

      enum_field_types type = (*result)[0].type;

      if(type != 8)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 8 for field id";

        throw Exception(ostr.str());
      }

      unsigned int flags = 
        (*result)[0].flags & (UNSIGNED_FLAG);

      if(flags != 0x20)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x20 for field id";

        throw Exception(ostr.str());
      }

      const char* name = (*result)[0].name;

      if(strcmp(name, "id"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of id for field id";

        throw Exception(ostr.str());
      }

      if(use_columns >= 1)
      {
        return;
      }

      type = (*result)[1].type;

      if(type != 2)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 2 for field type";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[1].flags & (UNSIGNED_FLAG);

      if(flags != 0x20)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x20 for field type";

        throw Exception(ostr.str());
      }

      name = (*result)[1].name;

      if(strcmp(name, "type"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of type for field type";

        throw Exception(ostr.str());
      }

      if(use_columns >= 2)
      {
        return;
      }

      type = (*result)[2].type;

      if(type != 253)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 253 for field url";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[2].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field url";

        throw Exception(ostr.str());
      }

      name = (*result)[2].name;

      if(strcmp(name, "url"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of url for field url";

        throw Exception(ostr.str());
      }

      if(use_columns >= 3)
      {
        return;
      }

      type = (*result)[3].type;

      if(type != 253)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 253 for field encoding";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[3].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field encoding";

        throw Exception(ostr.str());
      }

      name = (*result)[3].name;

      if(strcmp(name, "encoding"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of encoding for field encoding";

        throw Exception(ostr.str());
      }

      if(use_columns >= 4)
      {
        return;
      }

      type = (*result)[4].type;

      if(type != 2)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 2 for field space";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[4].flags & (UNSIGNED_FLAG);

      if(flags != 0x20)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x20 for field space";

        throw Exception(ostr.str());
      }

      name = (*result)[4].name;

      if(strcmp(name, "space"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of space for field space";

        throw Exception(ostr.str());
      }

      if(use_columns >= 5)
      {
        return;
      }

      type = (*result)[5].type;

      if(type != 2)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 2 for field lang";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[5].flags & (UNSIGNED_FLAG);

      if(flags != 0x20)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x20 for field lang";

        throw Exception(ostr.str());
      }

      name = (*result)[5].name;

      if(strcmp(name, "lang"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of lang for field lang";

        throw Exception(ostr.str());
      }

      if(use_columns >= 6)
      {
        return;
      }

      type = (*result)[6].type;

      if(type != 2)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 2 for field country";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[6].flags & (UNSIGNED_FLAG);

      if(flags != 0x20)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x20 for field country";

        throw Exception(ostr.str());
      }

      name = (*result)[6].name;

      if(strcmp(name, "country"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of country for field country";

        throw Exception(ostr.str());
      }

      if(use_columns >= 7)
      {
        return;
      }

      type = (*result)[7].type;

      if(type != 254)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 254 for field status";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[7].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field status";

        throw Exception(ostr.str());
      }

      name = (*result)[7].name;

      if(strcmp(name, "status"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of status for field status";

        throw Exception(ostr.str());
      }

      if(use_columns >= 8)
      {
        return;
      }

      type = (*result)[8].type;

      if(type != 8)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 8 for field creator";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[8].flags & (UNSIGNED_FLAG);

      if(flags != 0x20)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x20 for field creator";

        throw Exception(ostr.str());
      }

      name = (*result)[8].name;

      if(strcmp(name, "creator"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of creator for field creator";

        throw Exception(ostr.str());
      }

      if(use_columns >= 9)
      {
        return;
      }

      type = (*result)[9].type;

      if(type != 254)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 254 for field creator_type";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[9].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field creator_type";

        throw Exception(ostr.str());
      }

      name = (*result)[9].name;

      if(strcmp(name, "creator_type"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of creator_type for field creator_type";

        throw Exception(ostr.str());
      }

      if(use_columns >= 10)
      {
        return;
      }

      type = (*result)[10].type;

      if(type != 252)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 252 for field keywords";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[10].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field keywords";

        throw Exception(ostr.str());
      }

      name = (*result)[10].name;

      if(strcmp(name, "keywords"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of keywords for field keywords";

        throw Exception(ostr.str());
      }

      if(use_columns >= 11)
      {
        return;
      }

      type = (*result)[11].type;

      if(type != 252)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 252 for field adjustment_script";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[11].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field adjustment_script";

        throw Exception(ostr.str());
      }

      name = (*result)[11].name;

      if(strcmp(name, "adjustment_script"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of adjustment_script for field adjustment_script";

        throw Exception(ostr.str());
      }

      if(use_columns >= 12)
      {
        return;
      }

      type = (*result)[12].type;

      if(type != 252)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 252 for field comment";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[12].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field comment";

        throw Exception(ostr.str());
      }

      name = (*result)[12].name;

      if(strcmp(name, "comment"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of comment for field comment";

        throw Exception(ostr.str());
      }

      if(use_columns >= 13)
      {
        return;
      }

      type = (*result)[13].type;

      if(type != 7)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 7 for field created";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[13].flags & (UNSIGNED_FLAG);

      if(flags != 0x20)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x20 for field created";

        throw Exception(ostr.str());
      }

      name = (*result)[13].name;

      if(strcmp(name, "created"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of created for field created";

        throw Exception(ostr.str());
      }

      if(use_columns >= 14)
      {
        return;
      }

      type = (*result)[14].type;

      if(type != 7)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 7 for field updated";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[14].flags & (UNSIGNED_FLAG);

      if(flags != 0x20)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x20 for field updated";

        throw Exception(ostr.str());
      }

      name = (*result)[14].name;

      if(strcmp(name, "updated"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of updated for field updated";

        throw Exception(ostr.str());
      }

      if(use_columns >= 15)
      {
        return;
      }

      type = (*result)[15].type;

      if(type != 253)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 253 for field channel_title";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[15].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field channel_title";

        throw Exception(ostr.str());
      }

      name = (*result)[15].name;

      if(strcmp(name, "channel_title"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of channel_title for field channel_title";

        throw Exception(ostr.str());
      }

      if(use_columns >= 16)
      {
        return;
      }

      type = (*result)[16].type;

      if(type != 252)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 252 for field channel_description";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[16].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field channel_description";

        throw Exception(ostr.str());
      }

      name = (*result)[16].name;

      if(strcmp(name, "channel_description"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of channel_description for field channel_description";

        throw Exception(ostr.str());
      }

      if(use_columns >= 17)
      {
        return;
      }

      type = (*result)[17].type;

      if(type != 253)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 253 for field channel_html_link";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[17].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field channel_html_link";

        throw Exception(ostr.str());
      }

      name = (*result)[17].name;

      if(strcmp(name, "channel_html_link"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of channel_html_link for field channel_html_link";

        throw Exception(ostr.str());
      }

      if(use_columns >= 18)
      {
        return;
      }

      type = (*result)[18].type;

      if(type != 2)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 2 for field channel_lang";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[18].flags & (UNSIGNED_FLAG);

      if(flags != 0x20)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x20 for field channel_lang";

        throw Exception(ostr.str());
      }

      name = (*result)[18].name;

      if(strcmp(name, "channel_lang"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of channel_lang for field channel_lang";

        throw Exception(ostr.str());
      }

      if(use_columns >= 19)
      {
        return;
      }

      type = (*result)[19].type;

      if(type != 2)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 2 for field channel_country";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[19].flags & (UNSIGNED_FLAG);

      if(flags != 0x20)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x20 for field channel_country";

        throw Exception(ostr.str());
      }

      name = (*result)[19].name;

      if(strcmp(name, "channel_country"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of channel_country for field channel_country";

        throw Exception(ostr.str());
      }

      if(use_columns >= 20)
      {
        return;
      }

      type = (*result)[20].type;

      if(type != 2)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 2 for field channel_ttl";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[20].flags & (UNSIGNED_FLAG);

      if(flags != 0x20)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x20 for field channel_ttl";

        throw Exception(ostr.str());
      }

      name = (*result)[20].name;

      if(strcmp(name, "channel_ttl"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of channel_ttl for field channel_ttl";

        throw Exception(ostr.str());
      }

      if(use_columns >= 21)
      {
        return;
      }

      type = (*result)[21].type;

      if(type != 12)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 12 for field channel_last_build_date";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[21].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field channel_last_build_date";

        throw Exception(ostr.str());
      }

      name = (*result)[21].name;

      if(strcmp(name, "channel_last_build_date"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of channel_last_build_date for field channel_last_build_date";

        throw Exception(ostr.str());
      }

      if(use_columns >= 22)
      {
        return;
      }

      type = (*result)[22].type;

      if(type != 12)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 12 for field last_request_date";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[22].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field last_request_date";

        throw Exception(ostr.str());
      }

      name = (*result)[22].name;

      if(strcmp(name, "last_request_date"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of last_request_date for field last_request_date";

        throw Exception(ostr.str());
      }

      if(use_columns >= 23)
      {
        return;
      }

      type = (*result)[23].type;

      if(type != 253)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 253 for field last_modified_hdr";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[23].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field last_modified_hdr";

        throw Exception(ostr.str());
      }

      name = (*result)[23].name;

      if(strcmp(name, "last_modified_hdr"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of last_modified_hdr for field last_modified_hdr";

        throw Exception(ostr.str());
      }

      if(use_columns >= 24)
      {
        return;
      }

      type = (*result)[24].type;

      if(type != 253)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 253 for field etag_hdr";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[24].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field etag_hdr";

        throw Exception(ostr.str());
      }

      name = (*result)[24].name;

      if(strcmp(name, "etag_hdr"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of etag_hdr for field etag_hdr";

        throw Exception(ostr.str());
      }

      if(use_columns >= 25)
      {
        return;
      }

      type = (*result)[25].type;

      if(type != 8)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 8 for field content_length_hdr";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[25].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field content_length_hdr";

        throw Exception(ostr.str());
      }

      name = (*result)[25].name;

      if(strcmp(name, "content_length_hdr"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of content_length_hdr for field content_length_hdr";

        throw Exception(ostr.str());
      }

      if(use_columns >= 26)
      {
        return;
      }

      type = (*result)[26].type;

      if(type != 3)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 3 for field entropy";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[26].flags & (UNSIGNED_FLAG);

      if(flags != 0x20)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x20 for field entropy";

        throw Exception(ostr.str());
      }

      name = (*result)[26].name;

      if(strcmp(name, "entropy"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of entropy for field entropy";

        throw Exception(ostr.str());
      }

      if(use_columns >= 27)
      {
        return;
      }

      type = (*result)[27].type;

      if(type != 12)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 12 for field entropy_updated_date";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[27].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field entropy_updated_date";

        throw Exception(ostr.str());
      }

      name = (*result)[27].name;

      if(strcmp(name, "entropy_updated_date"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of entropy_updated_date for field entropy_updated_date";

        throw Exception(ostr.str());
      }

      if(use_columns >= 28)
      {
        return;
      }

      type = (*result)[28].type;

      if(type != 3)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 3 for field size";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[28].flags & (UNSIGNED_FLAG);

      if(flags != 0x20)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x20 for field size";

        throw Exception(ostr.str());
      }

      name = (*result)[28].name;

      if(strcmp(name, "size"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of size for field size";

        throw Exception(ostr.str());
      }

      if(use_columns >= 29)
      {
        return;
      }

      type = (*result)[29].type;

      if(type != 1)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 1 for field single_chunked";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[29].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field single_chunked";

        throw Exception(ostr.str());
      }

      name = (*result)[29].name;

      if(strcmp(name, "single_chunked"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of single_chunked for field single_chunked";

        throw Exception(ostr.str());
      }

      if(use_columns >= 30)
      {
        return;
      }

      type = (*result)[30].type;

      if(type != 8)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 8 for field first_chunk_size";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[30].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field first_chunk_size";

        throw Exception(ostr.str());
      }

      name = (*result)[30].name;

      if(strcmp(name, "first_chunk_size"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of first_chunk_size for field first_chunk_size";

        throw Exception(ostr.str());
      }

      if(use_columns >= 31)
      {
        return;
      }

      type = (*result)[31].type;

      if(type != 3)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 3 for field heuristics_counter";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[31].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field heuristics_counter";

        throw Exception(ostr.str());
      }

      name = (*result)[31].name;

      if(strcmp(name, "heuristics_counter"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of heuristics_counter for field heuristics_counter";

        throw Exception(ostr.str());
      }

      if(use_columns >= 32)
      {
        return;
      }

      type = (*result)[32].type;

      if(type != 246)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 246 for field requests";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[32].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field requests";

        throw Exception(ostr.str());
      }

      name = (*result)[32].name;

      if(strcmp(name, "requests"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of requests for field requests";

        throw Exception(ostr.str());
      }

      if(use_columns >= 33)
      {
        return;
      }

      type = (*result)[33].type;

      if(type != 246)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 246 for field failed";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[33].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field failed";

        throw Exception(ostr.str());
      }

      name = (*result)[33].name;

      if(strcmp(name, "failed"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of failed for field failed";

        throw Exception(ostr.str());
      }

      if(use_columns >= 34)
      {
        return;
      }

      type = (*result)[34].type;

      if(type != 246)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 246 for field unchanged";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[34].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field unchanged";

        throw Exception(ostr.str());
      }

      name = (*result)[34].name;

      if(strcmp(name, "unchanged"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of unchanged for field unchanged";

        throw Exception(ostr.str());
      }

      if(use_columns >= 35)
      {
        return;
      }

      type = (*result)[35].type;

      if(type != 246)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 246 for field not_modified";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[35].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field not_modified";

        throw Exception(ostr.str());
      }

      name = (*result)[35].name;

      if(strcmp(name, "not_modified"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of not_modified for field not_modified";

        throw Exception(ostr.str());
      }

      if(use_columns >= 36)
      {
        return;
      }

      type = (*result)[36].type;

      if(type != 246)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 246 for field presumably_unchanged";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[36].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field presumably_unchanged";

        throw Exception(ostr.str());
      }

      name = (*result)[36].name;

      if(strcmp(name, "presumably_unchanged"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of presumably_unchanged for field presumably_unchanged";

        throw Exception(ostr.str());
      }

      if(use_columns >= 37)
      {
        return;
      }

      type = (*result)[37].type;

      if(type != 246)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 246 for field has_changes";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[37].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field has_changes";

        throw Exception(ostr.str());
      }

      name = (*result)[37].name;

      if(strcmp(name, "has_changes"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of has_changes for field has_changes";

        throw Exception(ostr.str());
      }

      if(use_columns >= 38)
      {
        return;
      }

      type = (*result)[38].type;

      if(type != 5)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 5 for field wasted";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[38].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field wasted";

        throw Exception(ostr.str());
      }

      name = (*result)[38].name;

      if(strcmp(name, "wasted"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of wasted for field wasted";

        throw Exception(ostr.str());
      }

      if(use_columns >= 39)
      {
        return;
      }

      type = (*result)[39].type;

      if(type != 246)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 246 for field outbound";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[39].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field outbound";

        throw Exception(ostr.str());
      }

      name = (*result)[39].name;

      if(strcmp(name, "outbound"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of outbound for field outbound";

        throw Exception(ostr.str());
      }

      if(use_columns >= 40)
      {
        return;
      }

      type = (*result)[40].type;

      if(type != 246)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 246 for field inbound";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[40].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field inbound";

        throw Exception(ostr.str());
      }

      name = (*result)[40].name;

      if(strcmp(name, "inbound"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of inbound for field inbound";

        throw Exception(ostr.str());
      }

      if(use_columns >= 41)
      {
        return;
      }

      type = (*result)[41].type;

      if(type != 246)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 246 for field requests_duration";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[41].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field requests_duration";

        throw Exception(ostr.str());
      }

      name = (*result)[41].name;

      if(strcmp(name, "requests_duration"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of requests_duration for field requests_duration";

        throw Exception(ostr.str());
      }

      if(use_columns >= 42)
      {
        return;
      }

      type = (*result)[42].type;

      if(type != 246)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 246 for field messages";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[42].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field messages";

        throw Exception(ostr.str());
      }

      name = (*result)[42].name;

      if(strcmp(name, "messages"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of messages for field messages";

        throw Exception(ostr.str());
      }

      if(use_columns >= 43)
      {
        return;
      }

      type = (*result)[43].type;

      if(type != 246)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 246 for field messages_size";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[43].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field messages_size";

        throw Exception(ostr.str());
      }

      name = (*result)[43].name;

      if(strcmp(name, "messages_size"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of messages_size for field messages_size";

        throw Exception(ostr.str());
      }

      if(use_columns >= 44)
      {
        return;
      }

      type = (*result)[44].type;

      if(type != 246)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 246 for field messages_delay";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[44].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field messages_delay";

        throw Exception(ostr.str());
      }

      name = (*result)[44].name;

      if(strcmp(name, "messages_delay"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of messages_delay for field messages_delay";

        throw Exception(ostr.str());
      }

      if(use_columns >= 45)
      {
        return;
      }

      type = (*result)[45].type;

      if(type != 8)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 8 for field max_message_delay";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[45].flags & (UNSIGNED_FLAG);

      if(flags != 0x20)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x20 for field max_message_delay";

        throw Exception(ostr.str());
      }

      name = (*result)[45].name;

      if(strcmp(name, "max_message_delay"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of max_message_delay for field max_message_delay";

        throw Exception(ostr.str());
      }

      if(use_columns >= 46)
      {
        return;
      }

      type = (*result)[46].type;

      if(type != 246)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 246 for field msg_impressions";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[46].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field msg_impressions";

        throw Exception(ostr.str());
      }

      name = (*result)[46].name;

      if(strcmp(name, "msg_impressions"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of msg_impressions for field msg_impressions";

        throw Exception(ostr.str());
      }

      if(use_columns >= 47)
      {
        return;
      }

      type = (*result)[47].type;

      if(type != 246)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 246 for field msg_clicks";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[47].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field msg_clicks";

        throw Exception(ostr.str());
      }

      name = (*result)[47].name;

      if(strcmp(name, "msg_clicks"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of msg_clicks for field msg_clicks";

        throw Exception(ostr.str());
      }

      if(use_columns >= 48)
      {
        return;
      }

      type = (*result)[48].type;

      if(type != 246)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected type " << type
             << " instead of 246 for field msg_ctr";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[48].flags & (UNSIGNED_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field msg_ctr";

        throw Exception(ostr.str());
      }

      name = (*result)[48].name;

      if(strcmp(name, "msg_ctr"))
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::FeedRecord: unexpected name " << name
             << " instead of msg_ctr for field msg_ctr";

        throw Exception(ostr.str());
      }

    }

    inline
    El::MySQL::UnsignedLongLong
    FeedRecord::id() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::id: row_ is 0");
      }

      if(0 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::id: unexpected index 0 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      unsigned long long value = 0;
      bool is_null = row_[0] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[0], lengths[0]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::id: failed to convert 'id' field data"
            " to unsigned long long";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::UnsignedLongLong(is_null, value);
    }

    inline
    El::MySQL::UnsignedShort
    FeedRecord::type() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::type: row_ is 0");
      }

      if(1 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::type: unexpected index 1 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      unsigned short value = 0;
      bool is_null = row_[1] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[1], lengths[1]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::type: failed to convert 'type' field data"
            " to unsigned short";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::UnsignedShort(is_null, value);
    }

    inline
    El::MySQL::String
    FeedRecord::url() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::url: row_ is 0");
      }

      if(2 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::url: unexpected index 2 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[2] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[2], lengths[2]);

      return tmp;
    }

    inline
    El::MySQL::String
    FeedRecord::encoding() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::encoding: row_ is 0");
      }

      if(3 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::encoding: unexpected index 3 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[3] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[3], lengths[3]);

      return tmp;
    }

    inline
    El::MySQL::UnsignedShort
    FeedRecord::space() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::space: row_ is 0");
      }

      if(4 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::space: unexpected index 4 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      unsigned short value = 0;
      bool is_null = row_[4] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[4], lengths[4]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::space: failed to convert 'space' field data"
            " to unsigned short";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::UnsignedShort(is_null, value);
    }

    inline
    El::MySQL::UnsignedShort
    FeedRecord::lang() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::lang: row_ is 0");
      }

      if(5 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::lang: unexpected index 5 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      unsigned short value = 0;
      bool is_null = row_[5] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[5], lengths[5]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::lang: failed to convert 'lang' field data"
            " to unsigned short";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::UnsignedShort(is_null, value);
    }

    inline
    El::MySQL::UnsignedShort
    FeedRecord::country() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::country: row_ is 0");
      }

      if(6 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::country: unexpected index 6 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      unsigned short value = 0;
      bool is_null = row_[6] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[6], lengths[6]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::country: failed to convert 'country' field data"
            " to unsigned short";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::UnsignedShort(is_null, value);
    }

    inline
    El::MySQL::String
    FeedRecord::status() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::status: row_ is 0");
      }

      if(7 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::status: unexpected index 7 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[7] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[7], lengths[7]);

      return tmp;
    }

    inline
    El::MySQL::UnsignedLongLong
    FeedRecord::creator() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::creator: row_ is 0");
      }

      if(8 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::creator: unexpected index 8 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      unsigned long long value = 0;
      bool is_null = row_[8] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[8], lengths[8]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::creator: failed to convert 'creator' field data"
            " to unsigned long long";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::UnsignedLongLong(is_null, value);
    }

    inline
    El::MySQL::String
    FeedRecord::creator_type() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::creator_type: row_ is 0");
      }

      if(9 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::creator_type: unexpected index 9 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[9] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[9], lengths[9]);

      return tmp;
    }

    inline
    El::MySQL::String
    FeedRecord::keywords() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::keywords: row_ is 0");
      }

      if(10 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::keywords: unexpected index 10 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[10] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[10], lengths[10]);

      return tmp;
    }

    inline
    El::MySQL::String
    FeedRecord::adjustment_script() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::adjustment_script: row_ is 0");
      }

      if(11 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::adjustment_script: unexpected index 11 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[11] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[11], lengths[11]);

      return tmp;
    }

    inline
    El::MySQL::String
    FeedRecord::comment() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::comment: row_ is 0");
      }

      if(12 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::comment: unexpected index 12 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[12] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[12], lengths[12]);

      return tmp;
    }

    inline
    El::MySQL::DateTime
    FeedRecord::created() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::created: row_ is 0");
      }

      if(13 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::created: unexpected index 13 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[13] == 0)
      {
        El::MySQL::DateTime tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::DateTime tmp(false, row_[13], lengths[13]);

      return tmp;
    }

    inline
    El::MySQL::DateTime
    FeedRecord::updated() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::updated: row_ is 0");
      }

      if(14 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::updated: unexpected index 14 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[14] == 0)
      {
        El::MySQL::DateTime tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::DateTime tmp(false, row_[14], lengths[14]);

      return tmp;
    }

    inline
    El::MySQL::String
    FeedRecord::channel_title() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::channel_title: row_ is 0");
      }

      if(15 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::channel_title: unexpected index 15 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[15] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[15], lengths[15]);

      return tmp;
    }

    inline
    El::MySQL::String
    FeedRecord::channel_description() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::channel_description: row_ is 0");
      }

      if(16 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::channel_description: unexpected index 16 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[16] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[16], lengths[16]);

      return tmp;
    }

    inline
    El::MySQL::String
    FeedRecord::channel_html_link() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::channel_html_link: row_ is 0");
      }

      if(17 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::channel_html_link: unexpected index 17 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[17] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[17], lengths[17]);

      return tmp;
    }

    inline
    El::MySQL::UnsignedShort
    FeedRecord::channel_lang() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::channel_lang: row_ is 0");
      }

      if(18 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::channel_lang: unexpected index 18 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      unsigned short value = 0;
      bool is_null = row_[18] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[18], lengths[18]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::channel_lang: failed to convert 'channel_lang' field data"
            " to unsigned short";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::UnsignedShort(is_null, value);
    }

    inline
    El::MySQL::UnsignedShort
    FeedRecord::channel_country() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::channel_country: row_ is 0");
      }

      if(19 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::channel_country: unexpected index 19 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      unsigned short value = 0;
      bool is_null = row_[19] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[19], lengths[19]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::channel_country: failed to convert 'channel_country' field data"
            " to unsigned short";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::UnsignedShort(is_null, value);
    }

    inline
    El::MySQL::UnsignedShort
    FeedRecord::channel_ttl() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::channel_ttl: row_ is 0");
      }

      if(20 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::channel_ttl: unexpected index 20 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      unsigned short value = 0;
      bool is_null = row_[20] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[20], lengths[20]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::channel_ttl: failed to convert 'channel_ttl' field data"
            " to unsigned short";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::UnsignedShort(is_null, value);
    }

    inline
    El::MySQL::DateTime
    FeedRecord::channel_last_build_date() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::channel_last_build_date: row_ is 0");
      }

      if(21 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::channel_last_build_date: unexpected index 21 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[21] == 0)
      {
        El::MySQL::DateTime tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::DateTime tmp(false, row_[21], lengths[21]);

      return tmp;
    }

    inline
    El::MySQL::DateTime
    FeedRecord::last_request_date() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::last_request_date: row_ is 0");
      }

      if(22 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::last_request_date: unexpected index 22 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[22] == 0)
      {
        El::MySQL::DateTime tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::DateTime tmp(false, row_[22], lengths[22]);

      return tmp;
    }

    inline
    El::MySQL::String
    FeedRecord::last_modified_hdr() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::last_modified_hdr: row_ is 0");
      }

      if(23 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::last_modified_hdr: unexpected index 23 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[23] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[23], lengths[23]);

      return tmp;
    }

    inline
    El::MySQL::String
    FeedRecord::etag_hdr() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::etag_hdr: row_ is 0");
      }

      if(24 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::etag_hdr: unexpected index 24 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[24] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[24], lengths[24]);

      return tmp;
    }

    inline
    El::MySQL::LongLong
    FeedRecord::content_length_hdr() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::content_length_hdr: row_ is 0");
      }

      if(25 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::content_length_hdr: unexpected index 25 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      long long value = 0;
      bool is_null = row_[25] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[25], lengths[25]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::content_length_hdr: failed to convert 'content_length_hdr' field data"
            " to long long";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::LongLong(is_null, value);
    }

    inline
    El::MySQL::UnsignedLong
    FeedRecord::entropy() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::entropy: row_ is 0");
      }

      if(26 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::entropy: unexpected index 26 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      unsigned long value = 0;
      bool is_null = row_[26] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[26], lengths[26]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::entropy: failed to convert 'entropy' field data"
            " to unsigned long";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::UnsignedLong(is_null, value);
    }

    inline
    El::MySQL::DateTime
    FeedRecord::entropy_updated_date() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::entropy_updated_date: row_ is 0");
      }

      if(27 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::entropy_updated_date: unexpected index 27 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[27] == 0)
      {
        El::MySQL::DateTime tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::DateTime tmp(false, row_[27], lengths[27]);

      return tmp;
    }

    inline
    El::MySQL::UnsignedLong
    FeedRecord::size() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::size: row_ is 0");
      }

      if(28 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::size: unexpected index 28 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      unsigned long value = 0;
      bool is_null = row_[28] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[28], lengths[28]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::size: failed to convert 'size' field data"
            " to unsigned long";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::UnsignedLong(is_null, value);
    }

    inline
    El::MySQL::Char
    FeedRecord::single_chunked() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::single_chunked: row_ is 0");
      }

      if(29 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::single_chunked: unexpected index 29 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      short value = 0;
      bool is_null = row_[29] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[29], lengths[29]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::single_chunked: failed to convert 'single_chunked' field data"
            " to short";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::Char(is_null, value);
    }

    inline
    El::MySQL::LongLong
    FeedRecord::first_chunk_size() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::first_chunk_size: row_ is 0");
      }

      if(30 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::first_chunk_size: unexpected index 30 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      long long value = 0;
      bool is_null = row_[30] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[30], lengths[30]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::first_chunk_size: failed to convert 'first_chunk_size' field data"
            " to long long";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::LongLong(is_null, value);
    }

    inline
    El::MySQL::Long
    FeedRecord::heuristics_counter() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::heuristics_counter: row_ is 0");
      }

      if(31 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::heuristics_counter: unexpected index 31 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      long value = 0;
      bool is_null = row_[31] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[31], lengths[31]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::heuristics_counter: failed to convert 'heuristics_counter' field data"
            " to long";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::Long(is_null, value);
    }

    inline
    El::MySQL::Double
    FeedRecord::requests() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::requests: row_ is 0");
      }

      if(32 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::requests: unexpected index 32 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      double value = 0;
      bool is_null = row_[32] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[32], lengths[32]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::requests: failed to convert 'requests' field data"
            " to double";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::Double(is_null, value);
    }

    inline
    El::MySQL::Double
    FeedRecord::failed() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::failed: row_ is 0");
      }

      if(33 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::failed: unexpected index 33 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      double value = 0;
      bool is_null = row_[33] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[33], lengths[33]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::failed: failed to convert 'failed' field data"
            " to double";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::Double(is_null, value);
    }

    inline
    El::MySQL::Double
    FeedRecord::unchanged() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::unchanged: row_ is 0");
      }

      if(34 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::unchanged: unexpected index 34 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      double value = 0;
      bool is_null = row_[34] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[34], lengths[34]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::unchanged: failed to convert 'unchanged' field data"
            " to double";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::Double(is_null, value);
    }

    inline
    El::MySQL::Double
    FeedRecord::not_modified() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::not_modified: row_ is 0");
      }

      if(35 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::not_modified: unexpected index 35 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      double value = 0;
      bool is_null = row_[35] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[35], lengths[35]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::not_modified: failed to convert 'not_modified' field data"
            " to double";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::Double(is_null, value);
    }

    inline
    El::MySQL::Double
    FeedRecord::presumably_unchanged() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::presumably_unchanged: row_ is 0");
      }

      if(36 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::presumably_unchanged: unexpected index 36 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      double value = 0;
      bool is_null = row_[36] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[36], lengths[36]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::presumably_unchanged: failed to convert 'presumably_unchanged' field data"
            " to double";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::Double(is_null, value);
    }

    inline
    El::MySQL::Double
    FeedRecord::has_changes() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::has_changes: row_ is 0");
      }

      if(37 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::has_changes: unexpected index 37 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      double value = 0;
      bool is_null = row_[37] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[37], lengths[37]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::has_changes: failed to convert 'has_changes' field data"
            " to double";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::Double(is_null, value);
    }

    inline
    El::MySQL::Double
    FeedRecord::wasted() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::wasted: row_ is 0");
      }

      if(38 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::wasted: unexpected index 38 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      double value = 0;
      bool is_null = row_[38] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[38], lengths[38]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::wasted: failed to convert 'wasted' field data"
            " to double";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::Double(is_null, value);
    }

    inline
    El::MySQL::Double
    FeedRecord::outbound() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::outbound: row_ is 0");
      }

      if(39 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::outbound: unexpected index 39 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      double value = 0;
      bool is_null = row_[39] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[39], lengths[39]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::outbound: failed to convert 'outbound' field data"
            " to double";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::Double(is_null, value);
    }

    inline
    El::MySQL::Double
    FeedRecord::inbound() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::inbound: row_ is 0");
      }

      if(40 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::inbound: unexpected index 40 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      double value = 0;
      bool is_null = row_[40] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[40], lengths[40]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::inbound: failed to convert 'inbound' field data"
            " to double";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::Double(is_null, value);
    }

    inline
    El::MySQL::Double
    FeedRecord::requests_duration() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::requests_duration: row_ is 0");
      }

      if(41 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::requests_duration: unexpected index 41 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      double value = 0;
      bool is_null = row_[41] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[41], lengths[41]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::requests_duration: failed to convert 'requests_duration' field data"
            " to double";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::Double(is_null, value);
    }

    inline
    El::MySQL::Double
    FeedRecord::messages() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::messages: row_ is 0");
      }

      if(42 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::messages: unexpected index 42 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      double value = 0;
      bool is_null = row_[42] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[42], lengths[42]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::messages: failed to convert 'messages' field data"
            " to double";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::Double(is_null, value);
    }

    inline
    El::MySQL::Double
    FeedRecord::messages_size() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::messages_size: row_ is 0");
      }

      if(43 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::messages_size: unexpected index 43 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      double value = 0;
      bool is_null = row_[43] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[43], lengths[43]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::messages_size: failed to convert 'messages_size' field data"
            " to double";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::Double(is_null, value);
    }

    inline
    El::MySQL::Double
    FeedRecord::messages_delay() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::messages_delay: row_ is 0");
      }

      if(44 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::messages_delay: unexpected index 44 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      double value = 0;
      bool is_null = row_[44] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[44], lengths[44]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::messages_delay: failed to convert 'messages_delay' field data"
            " to double";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::Double(is_null, value);
    }

    inline
    El::MySQL::UnsignedLongLong
    FeedRecord::max_message_delay() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::max_message_delay: row_ is 0");
      }

      if(45 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::max_message_delay: unexpected index 45 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      unsigned long long value = 0;
      bool is_null = row_[45] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[45], lengths[45]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::max_message_delay: failed to convert 'max_message_delay' field data"
            " to unsigned long long";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::UnsignedLongLong(is_null, value);
    }

    inline
    El::MySQL::Double
    FeedRecord::msg_impressions() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::msg_impressions: row_ is 0");
      }

      if(46 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::msg_impressions: unexpected index 46 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      double value = 0;
      bool is_null = row_[46] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[46], lengths[46]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::msg_impressions: failed to convert 'msg_impressions' field data"
            " to double";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::Double(is_null, value);
    }

    inline
    El::MySQL::Double
    FeedRecord::msg_clicks() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::msg_clicks: row_ is 0");
      }

      if(47 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::msg_clicks: unexpected index 47 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      double value = 0;
      bool is_null = row_[47] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[47], lengths[47]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::msg_clicks: failed to convert 'msg_clicks' field data"
            " to double";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::Double(is_null, value);
    }

    inline
    El::MySQL::Double
    FeedRecord::msg_ctr() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedRecord::msg_ctr: row_ is 0");
      }

      if(48 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedRecord::msg_ctr: unexpected index 48 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      double value = 0;
      bool is_null = row_[48] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[48], lengths[48]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedRecord::msg_ctr: failed to convert 'msg_ctr' field data"
            " to double";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::Double(is_null, value);
    }

  }
}

namespace NewsGate
{
  namespace Moderation
  {
//
// FeedIdAndUrl class declaration
//
    class FeedIdAndUrl: public El::MySQL::Row
    {
    public:
      EL_EXCEPTION(Exception, El::MySQL::Exception);
      EL_EXCEPTION(IsNull, Exception);

    public:
      FeedIdAndUrl(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
        throw(Exception, El::Exception);

      El::MySQL::UnsignedLongLong id() const
       throw(Exception, El::Exception);

      El::MySQL::String url() const
       throw(Exception, El::Exception);

    };

//
// FeedIdAndUrl class definition
//
    inline
    FeedIdAndUrl::FeedIdAndUrl(El::MySQL::Result* result, unsigned long use_columns)
      throw(Exception, El::Exception)
        : Row(result)
    {
      unsigned long num_columns = std::min(use_columns, (unsigned long)2);

      if(result->num_fields() != num_columns)
      {
        std::ostringstream ostr;
        ostr << "FeedIdAndUrl::FeedIdAndUrl: unexpected number of fields "
             << result->num_fields() << " instead of " << num_columns;

        throw Exception(ostr.str());
      }

      if(use_columns >= 0)
      {
        return;
      }

      enum_field_types type = (*result)[0].type;

      if(type != 8)
      {
        std::ostringstream ostr;
        ostr << "FeedIdAndUrl::FeedIdAndUrl: unexpected type " << type
             << " instead of 8 for field id";

        throw Exception(ostr.str());
      }

      unsigned int flags = 
        (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

      if(flags != 0x21)
      {
        std::ostringstream ostr;
        ostr << "FeedIdAndUrl::FeedIdAndUrl: unexpected flags 0x" << std::hex
             << flags << " instead of 0x21 for field id";

        throw Exception(ostr.str());
      }

      const char* name = (*result)[0].name;

      if(strcmp(name, "id"))
      {
        std::ostringstream ostr;
        ostr << "FeedIdAndUrl::FeedIdAndUrl: unexpected name " << name
             << " instead of id for field id";

        throw Exception(ostr.str());
      }

      if(use_columns >= 1)
      {
        return;
      }

      type = (*result)[1].type;

      if(type != 253)
      {
        std::ostringstream ostr;
        ostr << "FeedIdAndUrl::FeedIdAndUrl: unexpected type " << type
             << " instead of 253 for field url";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

      if(flags != 0x81)
      {
        std::ostringstream ostr;
        ostr << "FeedIdAndUrl::FeedIdAndUrl: unexpected flags 0x" << std::hex
             << flags << " instead of 0x81 for field url";

        throw Exception(ostr.str());
      }

      name = (*result)[1].name;

      if(strcmp(name, "url"))
      {
        std::ostringstream ostr;
        ostr << "FeedIdAndUrl::FeedIdAndUrl: unexpected name " << name
             << " instead of url for field url";

        throw Exception(ostr.str());
      }

    }

    inline
    El::MySQL::UnsignedLongLong
    FeedIdAndUrl::id() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedIdAndUrl::id: row_ is 0");
      }

      if(0 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedIdAndUrl::id: unexpected index 0 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      unsigned long long value = 0;
      bool is_null = row_[0] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[0], lengths[0]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "FeedIdAndUrl::id: failed to convert 'id' field data"
            " to unsigned long long";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::UnsignedLongLong(is_null, value);
    }

    inline
    El::MySQL::String
    FeedIdAndUrl::url() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("FeedIdAndUrl::url: row_ is 0");
      }

      if(1 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "FeedIdAndUrl::url: unexpected index 1 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[1] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[1], lengths[1]);

      return tmp;
    }

  }
}

namespace NewsGate
{
  namespace Moderation
  {
//
// MessageFilterUpdateNum class declaration
//
    class MessageFilterUpdateNum: public El::MySQL::Row
    {
    public:
      EL_EXCEPTION(Exception, El::MySQL::Exception);
      EL_EXCEPTION(IsNull, Exception);

    public:
      MessageFilterUpdateNum(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
        throw(Exception, El::Exception);

      El::MySQL::UnsignedLongLong update_num() const
       throw(Exception, El::Exception);

    };

//
// MessageFilterUpdateNum class definition
//
    inline
    MessageFilterUpdateNum::MessageFilterUpdateNum(El::MySQL::Result* result, unsigned long use_columns)
      throw(Exception, El::Exception)
        : Row(result)
    {
      unsigned long num_columns = std::min(use_columns, (unsigned long)1);

      if(result->num_fields() != num_columns)
      {
        std::ostringstream ostr;
        ostr << "MessageFilterUpdateNum::MessageFilterUpdateNum: unexpected number of fields "
             << result->num_fields() << " instead of " << num_columns;

        throw Exception(ostr.str());
      }

      if(use_columns >= 0)
      {
        return;
      }

      enum_field_types type = (*result)[0].type;

      if(type != 8)
      {
        std::ostringstream ostr;
        ostr << "MessageFilterUpdateNum::MessageFilterUpdateNum: unexpected type " << type
             << " instead of 8 for field update_num";

        throw Exception(ostr.str());
      }

      unsigned int flags = 
        (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

      if(flags != 0x21)
      {
        std::ostringstream ostr;
        ostr << "MessageFilterUpdateNum::MessageFilterUpdateNum: unexpected flags 0x" << std::hex
             << flags << " instead of 0x21 for field update_num";

        throw Exception(ostr.str());
      }

      const char* name = (*result)[0].name;

      if(strcmp(name, "update_num"))
      {
        std::ostringstream ostr;
        ostr << "MessageFilterUpdateNum::MessageFilterUpdateNum: unexpected name " << name
             << " instead of update_num for field update_num";

        throw Exception(ostr.str());
      }

    }

    inline
    El::MySQL::UnsignedLongLong
    MessageFilterUpdateNum::update_num() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("MessageFilterUpdateNum::update_num: row_ is 0");
      }

      if(0 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "MessageFilterUpdateNum::update_num: unexpected index 0 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      unsigned long long value = 0;
      bool is_null = row_[0] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[0], lengths[0]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "MessageFilterUpdateNum::update_num: failed to convert 'update_num' field data"
            " to unsigned long long";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::UnsignedLongLong(is_null, value);
    }

  }
}

namespace NewsGate
{
  namespace Moderation
  {
//
// MessageFetchFilter class declaration
//
    class MessageFetchFilter: public El::MySQL::Row
    {
    public:
      EL_EXCEPTION(Exception, El::MySQL::Exception);
      EL_EXCEPTION(IsNull, Exception);

    public:
      MessageFetchFilter(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
        throw(Exception, El::Exception);

      El::MySQL::String expression() const
       throw(Exception, El::Exception);

      El::MySQL::String description() const
       throw(Exception, El::Exception);

    };

//
// MessageFetchFilter class definition
//
    inline
    MessageFetchFilter::MessageFetchFilter(El::MySQL::Result* result, unsigned long use_columns)
      throw(Exception, El::Exception)
        : Row(result)
    {
      unsigned long num_columns = std::min(use_columns, (unsigned long)2);

      if(result->num_fields() != num_columns)
      {
        std::ostringstream ostr;
        ostr << "MessageFetchFilter::MessageFetchFilter: unexpected number of fields "
             << result->num_fields() << " instead of " << num_columns;

        throw Exception(ostr.str());
      }

      if(use_columns >= 0)
      {
        return;
      }

      enum_field_types type = (*result)[0].type;

      if(type != 252)
      {
        std::ostringstream ostr;
        ostr << "MessageFetchFilter::MessageFetchFilter: unexpected type " << type
             << " instead of 252 for field expression";

        throw Exception(ostr.str());
      }

      unsigned int flags = 
        (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "MessageFetchFilter::MessageFetchFilter: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field expression";

        throw Exception(ostr.str());
      }

      const char* name = (*result)[0].name;

      if(strcmp(name, "expression"))
      {
        std::ostringstream ostr;
        ostr << "MessageFetchFilter::MessageFetchFilter: unexpected name " << name
             << " instead of expression for field expression";

        throw Exception(ostr.str());
      }

      if(use_columns >= 1)
      {
        return;
      }

      type = (*result)[1].type;

      if(type != 252)
      {
        std::ostringstream ostr;
        ostr << "MessageFetchFilter::MessageFetchFilter: unexpected type " << type
             << " instead of 252 for field description";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "MessageFetchFilter::MessageFetchFilter: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field description";

        throw Exception(ostr.str());
      }

      name = (*result)[1].name;

      if(strcmp(name, "description"))
      {
        std::ostringstream ostr;
        ostr << "MessageFetchFilter::MessageFetchFilter: unexpected name " << name
             << " instead of description for field description";

        throw Exception(ostr.str());
      }

    }

    inline
    El::MySQL::String
    MessageFetchFilter::expression() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("MessageFetchFilter::expression: row_ is 0");
      }

      if(0 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "MessageFetchFilter::expression: unexpected index 0 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[0] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[0], lengths[0]);

      return tmp;
    }

    inline
    El::MySQL::String
    MessageFetchFilter::description() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("MessageFetchFilter::description: row_ is 0");
      }

      if(1 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "MessageFetchFilter::description: unexpected index 1 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[1] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[1], lengths[1]);

      return tmp;
    }

  }
}

#endif // _NEWSGATE_MODERATION_FEEDTYPERECORD__1784554767_
