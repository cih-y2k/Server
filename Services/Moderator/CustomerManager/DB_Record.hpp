/*
 * product   : NewsGate - news search WEB server
 * copyright : Copyright (c) 2005-2016 Karen Arutyunov
 * licenses  : CC BY-NC-SA 3.0; see accompanying LICENSE file
 *             Commercial; contact karen.arutyunov@gmail.com
 */

// Copyright (C) 2005-2008 Karen Arutyunov
//
// This program was generated by MySQL Class Generating Compiler
// MySQLClassGen (TM)
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA

#ifndef _NEWSGATE_MODERATION_CUSTOMER_CUSTOMERBALANCE__1784554767_
#define _NEWSGATE_MODERATION_CUSTOMER_CUSTOMERBALANCE__1784554767_

#include <limits.h>

#include <string>
#include <sstream>

#include <El/Exception.hpp>
#include <El/MySQL/DB.hpp>

namespace NewsGate
{
  namespace Moderation
  {
    namespace Customer
    {
//
// CustomerBalance class declaration
//
      class CustomerBalance: public El::MySQL::Row
      {
      public:
        EL_EXCEPTION(Exception, El::MySQL::Exception);
        EL_EXCEPTION(IsNull, Exception);

      public:
        CustomerBalance(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
          throw(Exception, El::Exception);

        El::MySQL::Double balance() const
         throw(Exception, El::Exception);

      };

//
// CustomerBalance class definition
//
      inline
      CustomerBalance::CustomerBalance(El::MySQL::Result* result, unsigned long use_columns)
        throw(Exception, El::Exception)
          : Row(result)
      {
        unsigned long num_columns = std::min(use_columns, (unsigned long)1);

        if(result->num_fields() != num_columns)
        {
          std::ostringstream ostr;
          ostr << "CustomerBalance::CustomerBalance: unexpected number of fields "
               << result->num_fields() << " instead of " << num_columns;

          throw Exception(ostr.str());
        }

        if(use_columns >= 0)
        {
          return;
        }

        enum_field_types type = (*result)[0].type;

        if(type != 5)
        {
          std::ostringstream ostr;
          ostr << "CustomerBalance::CustomerBalance: unexpected type " << type
               << " instead of 5 for field balance";

          throw Exception(ostr.str());
        }

        unsigned int flags = 
          (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "CustomerBalance::CustomerBalance: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field balance";

          throw Exception(ostr.str());
        }

        const char* name = (*result)[0].name;

        if(strcmp(name, "balance"))
        {
          std::ostringstream ostr;
          ostr << "CustomerBalance::CustomerBalance: unexpected name " << name
               << " instead of balance for field balance";

          throw Exception(ostr.str());
        }

      }

      inline
      El::MySQL::Double
      CustomerBalance::balance() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("CustomerBalance::balance: row_ is 0");
        }

        if(0 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "CustomerBalance::balance: unexpected index 0 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        double value = 0;
        bool is_null = row_[0] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[0], lengths[0]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "CustomerBalance::balance: failed to convert 'balance' field data"
              " to double";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::Double(is_null, value);
      }

    }
  }
}

namespace NewsGate
{
  namespace Moderation
  {
    namespace Customer
    {
//
// Customer class declaration
//
      class Customer: public El::MySQL::Row
      {
      public:
        EL_EXCEPTION(Exception, El::MySQL::Exception);
        EL_EXCEPTION(IsNull, Exception);

      public:
        Customer(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
          throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong id() const
         throw(Exception, El::Exception);

        El::MySQL::String status() const
         throw(Exception, El::Exception);

        El::MySQL::Double balance() const
         throw(Exception, El::Exception);

      };

//
// Customer class definition
//
      inline
      Customer::Customer(El::MySQL::Result* result, unsigned long use_columns)
        throw(Exception, El::Exception)
          : Row(result)
      {
        unsigned long num_columns = std::min(use_columns, (unsigned long)3);

        if(result->num_fields() != num_columns)
        {
          std::ostringstream ostr;
          ostr << "Customer::Customer: unexpected number of fields "
               << result->num_fields() << " instead of " << num_columns;

          throw Exception(ostr.str());
        }

        if(use_columns >= 0)
        {
          return;
        }

        enum_field_types type = (*result)[0].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "Customer::Customer: unexpected type " << type
               << " instead of 8 for field id";

          throw Exception(ostr.str());
        }

        unsigned int flags = 
          (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "Customer::Customer: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field id";

          throw Exception(ostr.str());
        }

        const char* name = (*result)[0].name;

        if(strcmp(name, "id"))
        {
          std::ostringstream ostr;
          ostr << "Customer::Customer: unexpected name " << name
               << " instead of id for field id";

          throw Exception(ostr.str());
        }

        if(use_columns >= 1)
        {
          return;
        }

        type = (*result)[1].type;

        if(type != 254)
        {
          std::ostringstream ostr;
          ostr << "Customer::Customer: unexpected type " << type
               << " instead of 254 for field status";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "Customer::Customer: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field status";

          throw Exception(ostr.str());
        }

        name = (*result)[1].name;

        if(strcmp(name, "status"))
        {
          std::ostringstream ostr;
          ostr << "Customer::Customer: unexpected name " << name
               << " instead of status for field status";

          throw Exception(ostr.str());
        }

        if(use_columns >= 2)
        {
          return;
        }

        type = (*result)[2].type;

        if(type != 5)
        {
          std::ostringstream ostr;
          ostr << "Customer::Customer: unexpected type " << type
               << " instead of 5 for field balance";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "Customer::Customer: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field balance";

          throw Exception(ostr.str());
        }

        name = (*result)[2].name;

        if(strcmp(name, "balance"))
        {
          std::ostringstream ostr;
          ostr << "Customer::Customer: unexpected name " << name
               << " instead of balance for field balance";

          throw Exception(ostr.str());
        }

      }

      inline
      El::MySQL::UnsignedLongLong
      Customer::id() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Customer::id: row_ is 0");
        }

        if(0 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Customer::id: unexpected index 0 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[0] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[0], lengths[0]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "Customer::id: failed to convert 'id' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::String
      Customer::status() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Customer::status: row_ is 0");
        }

        if(1 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Customer::status: unexpected index 1 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[1] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[1], lengths[1]);

        return tmp;
      }

      inline
      El::MySQL::Double
      Customer::balance() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Customer::balance: row_ is 0");
        }

        if(2 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Customer::balance: unexpected index 2 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        double value = 0;
        bool is_null = row_[2] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[2], lengths[2]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "Customer::balance: failed to convert 'balance' field data"
              " to double";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::Double(is_null, value);
      }

    }
  }
}

#endif // _NEWSGATE_MODERATION_CUSTOMER_CUSTOMERBALANCE__1784554767_
