/*
 * product   : NewsGate - news search WEB server
 * copyright : Copyright (c) 2005-2016 Karen Arutyunov
 * licenses  : CC BY-NC-SA 3.0; see accompanying LICENSE file
 *             Commercial; contact karen.arutyunov@gmail.com
 */

// Copyright (C) 2005-2008 Karen Arutyunov
//
// This program was generated by MySQL Class Generating Compiler
// MySQLClassGen (TM)
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA

#ifndef _NEWSGATE_MODERATION_MODERATORRECORD__2087742441_
#define _NEWSGATE_MODERATION_MODERATORRECORD__2087742441_

#include <limits.h>

#include <string>
#include <sstream>

#include <El/Exception.hpp>
#include <El/MySQL/DB.hpp>

namespace NewsGate
{
  namespace Moderation
  {
//
// ModeratorRecord class declaration
//
    class ModeratorRecord: public El::MySQL::Row
    {
    public:
      EL_EXCEPTION(Exception, El::MySQL::Exception);
      EL_EXCEPTION(IsNull, Exception);

    public:
      ModeratorRecord(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
        throw(Exception, El::Exception);

      El::MySQL::UnsignedLongLong id() const
       throw(Exception, El::Exception);

      El::MySQL::String name() const
       throw(Exception, El::Exception);

      El::MySQL::String password_digest() const
       throw(Exception, El::Exception);

      El::MySQL::String email() const
       throw(Exception, El::Exception);

      El::MySQL::DateTime updated() const
       throw(Exception, El::Exception);

      El::MySQL::DateTime created() const
       throw(Exception, El::Exception);

      El::MySQL::UnsignedLongLong creator() const
       throw(Exception, El::Exception);

      El::MySQL::UnsignedLongLong superior() const
       throw(Exception, El::Exception);

      El::MySQL::String status() const
       throw(Exception, El::Exception);

      El::MySQL::String show_deleted() const
       throw(Exception, El::Exception);

      El::MySQL::String comment() const
       throw(Exception, El::Exception);

    };

//
// ModeratorRecord class definition
//
    inline
    ModeratorRecord::ModeratorRecord(El::MySQL::Result* result, unsigned long use_columns)
      throw(Exception, El::Exception)
        : Row(result)
    {
      unsigned long num_columns = std::min(use_columns, (unsigned long)11);

      if(result->num_fields() != num_columns)
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected number of fields "
             << result->num_fields() << " instead of " << num_columns;

        throw Exception(ostr.str());
      }

      if(use_columns >= 0)
      {
        return;
      }

      enum_field_types type = (*result)[0].type;

      if(type != 8)
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected type " << type
             << " instead of 8 for field id";

        throw Exception(ostr.str());
      }

      unsigned int flags = 
        (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

      if(flags != 0x21)
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x21 for field id";

        throw Exception(ostr.str());
      }

      const char* name = (*result)[0].name;

      if(strcmp(name, "id"))
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected name " << name
             << " instead of id for field id";

        throw Exception(ostr.str());
      }

      if(use_columns >= 1)
      {
        return;
      }

      type = (*result)[1].type;

      if(type != 253)
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected type " << type
             << " instead of 253 for field name";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

      if(flags != 0x1)
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x1 for field name";

        throw Exception(ostr.str());
      }

      name = (*result)[1].name;

      if(strcmp(name, "name"))
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected name " << name
             << " instead of name for field name";

        throw Exception(ostr.str());
      }

      if(use_columns >= 2)
      {
        return;
      }

      type = (*result)[2].type;

      if(type != 253)
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected type " << type
             << " instead of 253 for field password_digest";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

      if(flags != 0x1)
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x1 for field password_digest";

        throw Exception(ostr.str());
      }

      name = (*result)[2].name;

      if(strcmp(name, "password_digest"))
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected name " << name
             << " instead of password_digest for field password_digest";

        throw Exception(ostr.str());
      }

      if(use_columns >= 3)
      {
        return;
      }

      type = (*result)[3].type;

      if(type != 253)
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected type " << type
             << " instead of 253 for field email";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[3].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

      if(flags != 0x1)
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x1 for field email";

        throw Exception(ostr.str());
      }

      name = (*result)[3].name;

      if(strcmp(name, "email"))
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected name " << name
             << " instead of email for field email";

        throw Exception(ostr.str());
      }

      if(use_columns >= 4)
      {
        return;
      }

      type = (*result)[4].type;

      if(type != 7)
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected type " << type
             << " instead of 7 for field updated";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[4].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

      if(flags != 0xa1)
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0xa1 for field updated";

        throw Exception(ostr.str());
      }

      name = (*result)[4].name;

      if(strcmp(name, "updated"))
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected name " << name
             << " instead of updated for field updated";

        throw Exception(ostr.str());
      }

      if(use_columns >= 5)
      {
        return;
      }

      type = (*result)[5].type;

      if(type != 7)
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected type " << type
             << " instead of 7 for field created";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[5].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

      if(flags != 0xa1)
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0xa1 for field created";

        throw Exception(ostr.str());
      }

      name = (*result)[5].name;

      if(strcmp(name, "created"))
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected name " << name
             << " instead of created for field created";

        throw Exception(ostr.str());
      }

      if(use_columns >= 6)
      {
        return;
      }

      type = (*result)[6].type;

      if(type != 8)
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected type " << type
             << " instead of 8 for field creator";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[6].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

      if(flags != 0x21)
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x21 for field creator";

        throw Exception(ostr.str());
      }

      name = (*result)[6].name;

      if(strcmp(name, "creator"))
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected name " << name
             << " instead of creator for field creator";

        throw Exception(ostr.str());
      }

      if(use_columns >= 7)
      {
        return;
      }

      type = (*result)[7].type;

      if(type != 8)
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected type " << type
             << " instead of 8 for field superior";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[7].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

      if(flags != 0x21)
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x21 for field superior";

        throw Exception(ostr.str());
      }

      name = (*result)[7].name;

      if(strcmp(name, "superior"))
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected name " << name
             << " instead of superior for field superior";

        throw Exception(ostr.str());
      }

      if(use_columns >= 8)
      {
        return;
      }

      type = (*result)[8].type;

      if(type != 254)
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected type " << type
             << " instead of 254 for field status";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[8].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

      if(flags != 0x1)
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x1 for field status";

        throw Exception(ostr.str());
      }

      name = (*result)[8].name;

      if(strcmp(name, "status"))
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected name " << name
             << " instead of status for field status";

        throw Exception(ostr.str());
      }

      if(use_columns >= 9)
      {
        return;
      }

      type = (*result)[9].type;

      if(type != 254)
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected type " << type
             << " instead of 254 for field show_deleted";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[9].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

      if(flags != 0x1)
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x1 for field show_deleted";

        throw Exception(ostr.str());
      }

      name = (*result)[9].name;

      if(strcmp(name, "show_deleted"))
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected name " << name
             << " instead of show_deleted for field show_deleted";

        throw Exception(ostr.str());
      }

      if(use_columns >= 10)
      {
        return;
      }

      type = (*result)[10].type;

      if(type != 252)
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected type " << type
             << " instead of 252 for field comment";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[10].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field comment";

        throw Exception(ostr.str());
      }

      name = (*result)[10].name;

      if(strcmp(name, "comment"))
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::ModeratorRecord: unexpected name " << name
             << " instead of comment for field comment";

        throw Exception(ostr.str());
      }

    }

    inline
    El::MySQL::UnsignedLongLong
    ModeratorRecord::id() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("ModeratorRecord::id: row_ is 0");
      }

      if(0 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::id: unexpected index 0 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      unsigned long long value = 0;
      bool is_null = row_[0] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[0], lengths[0]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "ModeratorRecord::id: failed to convert 'id' field data"
            " to unsigned long long";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::UnsignedLongLong(is_null, value);
    }

    inline
    El::MySQL::String
    ModeratorRecord::name() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("ModeratorRecord::name: row_ is 0");
      }

      if(1 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::name: unexpected index 1 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[1] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[1], lengths[1]);

      return tmp;
    }

    inline
    El::MySQL::String
    ModeratorRecord::password_digest() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("ModeratorRecord::password_digest: row_ is 0");
      }

      if(2 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::password_digest: unexpected index 2 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[2] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[2], lengths[2]);

      return tmp;
    }

    inline
    El::MySQL::String
    ModeratorRecord::email() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("ModeratorRecord::email: row_ is 0");
      }

      if(3 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::email: unexpected index 3 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[3] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[3], lengths[3]);

      return tmp;
    }

    inline
    El::MySQL::DateTime
    ModeratorRecord::updated() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("ModeratorRecord::updated: row_ is 0");
      }

      if(4 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::updated: unexpected index 4 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[4] == 0)
      {
        El::MySQL::DateTime tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::DateTime tmp(false, row_[4], lengths[4]);

      return tmp;
    }

    inline
    El::MySQL::DateTime
    ModeratorRecord::created() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("ModeratorRecord::created: row_ is 0");
      }

      if(5 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::created: unexpected index 5 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[5] == 0)
      {
        El::MySQL::DateTime tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::DateTime tmp(false, row_[5], lengths[5]);

      return tmp;
    }

    inline
    El::MySQL::UnsignedLongLong
    ModeratorRecord::creator() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("ModeratorRecord::creator: row_ is 0");
      }

      if(6 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::creator: unexpected index 6 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      unsigned long long value = 0;
      bool is_null = row_[6] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[6], lengths[6]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "ModeratorRecord::creator: failed to convert 'creator' field data"
            " to unsigned long long";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::UnsignedLongLong(is_null, value);
    }

    inline
    El::MySQL::UnsignedLongLong
    ModeratorRecord::superior() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("ModeratorRecord::superior: row_ is 0");
      }

      if(7 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::superior: unexpected index 7 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      unsigned long long value = 0;
      bool is_null = row_[7] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[7], lengths[7]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "ModeratorRecord::superior: failed to convert 'superior' field data"
            " to unsigned long long";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::UnsignedLongLong(is_null, value);
    }

    inline
    El::MySQL::String
    ModeratorRecord::status() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("ModeratorRecord::status: row_ is 0");
      }

      if(8 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::status: unexpected index 8 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[8] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[8], lengths[8]);

      return tmp;
    }

    inline
    El::MySQL::String
    ModeratorRecord::show_deleted() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("ModeratorRecord::show_deleted: row_ is 0");
      }

      if(9 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::show_deleted: unexpected index 9 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[9] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[9], lengths[9]);

      return tmp;
    }

    inline
    El::MySQL::String
    ModeratorRecord::comment() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("ModeratorRecord::comment: row_ is 0");
      }

      if(10 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "ModeratorRecord::comment: unexpected index 10 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[10] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[10], lengths[10]);

      return tmp;
    }

  }
}

namespace NewsGate
{
  namespace Moderation
  {
//
// ModeratorPrivilegeRecord class declaration
//
    class ModeratorPrivilegeRecord: public El::MySQL::Row
    {
    public:
      EL_EXCEPTION(Exception, El::MySQL::Exception);
      EL_EXCEPTION(IsNull, Exception);

    public:
      ModeratorPrivilegeRecord(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
        throw(Exception, El::Exception);

      El::MySQL::UnsignedLongLong moderator() const
       throw(Exception, El::Exception);

      El::MySQL::UnsignedLongLong privilege() const
       throw(Exception, El::Exception);

      El::MySQL::UnsignedLongLong granted_by() const
       throw(Exception, El::Exception);

      El::MySQL::String args() const
       throw(Exception, El::Exception);

    };

//
// ModeratorPrivilegeRecord class definition
//
    inline
    ModeratorPrivilegeRecord::ModeratorPrivilegeRecord(El::MySQL::Result* result, unsigned long use_columns)
      throw(Exception, El::Exception)
        : Row(result)
    {
      unsigned long num_columns = std::min(use_columns, (unsigned long)4);

      if(result->num_fields() != num_columns)
      {
        std::ostringstream ostr;
        ostr << "ModeratorPrivilegeRecord::ModeratorPrivilegeRecord: unexpected number of fields "
             << result->num_fields() << " instead of " << num_columns;

        throw Exception(ostr.str());
      }

      if(use_columns >= 0)
      {
        return;
      }

      enum_field_types type = (*result)[0].type;

      if(type != 8)
      {
        std::ostringstream ostr;
        ostr << "ModeratorPrivilegeRecord::ModeratorPrivilegeRecord: unexpected type " << type
             << " instead of 8 for field moderator";

        throw Exception(ostr.str());
      }

      unsigned int flags = 
        (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

      if(flags != 0x21)
      {
        std::ostringstream ostr;
        ostr << "ModeratorPrivilegeRecord::ModeratorPrivilegeRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x21 for field moderator";

        throw Exception(ostr.str());
      }

      const char* name = (*result)[0].name;

      if(strcmp(name, "moderator"))
      {
        std::ostringstream ostr;
        ostr << "ModeratorPrivilegeRecord::ModeratorPrivilegeRecord: unexpected name " << name
             << " instead of moderator for field moderator";

        throw Exception(ostr.str());
      }

      if(use_columns >= 1)
      {
        return;
      }

      type = (*result)[1].type;

      if(type != 8)
      {
        std::ostringstream ostr;
        ostr << "ModeratorPrivilegeRecord::ModeratorPrivilegeRecord: unexpected type " << type
             << " instead of 8 for field privilege";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

      if(flags != 0x21)
      {
        std::ostringstream ostr;
        ostr << "ModeratorPrivilegeRecord::ModeratorPrivilegeRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x21 for field privilege";

        throw Exception(ostr.str());
      }

      name = (*result)[1].name;

      if(strcmp(name, "privilege"))
      {
        std::ostringstream ostr;
        ostr << "ModeratorPrivilegeRecord::ModeratorPrivilegeRecord: unexpected name " << name
             << " instead of privilege for field privilege";

        throw Exception(ostr.str());
      }

      if(use_columns >= 2)
      {
        return;
      }

      type = (*result)[2].type;

      if(type != 8)
      {
        std::ostringstream ostr;
        ostr << "ModeratorPrivilegeRecord::ModeratorPrivilegeRecord: unexpected type " << type
             << " instead of 8 for field granted_by";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

      if(flags != 0x21)
      {
        std::ostringstream ostr;
        ostr << "ModeratorPrivilegeRecord::ModeratorPrivilegeRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x21 for field granted_by";

        throw Exception(ostr.str());
      }

      name = (*result)[2].name;

      if(strcmp(name, "granted_by"))
      {
        std::ostringstream ostr;
        ostr << "ModeratorPrivilegeRecord::ModeratorPrivilegeRecord: unexpected name " << name
             << " instead of granted_by for field granted_by";

        throw Exception(ostr.str());
      }

      if(use_columns >= 3)
      {
        return;
      }

      type = (*result)[3].type;

      if(type != 252)
      {
        std::ostringstream ostr;
        ostr << "ModeratorPrivilegeRecord::ModeratorPrivilegeRecord: unexpected type " << type
             << " instead of 252 for field args";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[3].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "ModeratorPrivilegeRecord::ModeratorPrivilegeRecord: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field args";

        throw Exception(ostr.str());
      }

      name = (*result)[3].name;

      if(strcmp(name, "args"))
      {
        std::ostringstream ostr;
        ostr << "ModeratorPrivilegeRecord::ModeratorPrivilegeRecord: unexpected name " << name
             << " instead of args for field args";

        throw Exception(ostr.str());
      }

    }

    inline
    El::MySQL::UnsignedLongLong
    ModeratorPrivilegeRecord::moderator() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("ModeratorPrivilegeRecord::moderator: row_ is 0");
      }

      if(0 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "ModeratorPrivilegeRecord::moderator: unexpected index 0 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      unsigned long long value = 0;
      bool is_null = row_[0] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[0], lengths[0]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "ModeratorPrivilegeRecord::moderator: failed to convert 'moderator' field data"
            " to unsigned long long";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::UnsignedLongLong(is_null, value);
    }

    inline
    El::MySQL::UnsignedLongLong
    ModeratorPrivilegeRecord::privilege() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("ModeratorPrivilegeRecord::privilege: row_ is 0");
      }

      if(1 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "ModeratorPrivilegeRecord::privilege: unexpected index 1 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      unsigned long long value = 0;
      bool is_null = row_[1] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[1], lengths[1]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "ModeratorPrivilegeRecord::privilege: failed to convert 'privilege' field data"
            " to unsigned long long";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::UnsignedLongLong(is_null, value);
    }

    inline
    El::MySQL::UnsignedLongLong
    ModeratorPrivilegeRecord::granted_by() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("ModeratorPrivilegeRecord::granted_by: row_ is 0");
      }

      if(2 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "ModeratorPrivilegeRecord::granted_by: unexpected index 2 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      unsigned long long value = 0;
      bool is_null = row_[2] == 0;

      if(!is_null)
      {
        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        std::string tmp;
        tmp.assign(row_[2], lengths[2]);

        std::istringstream istr(tmp);
        istr >> value;

        if(istr.fail())
        {
          std::ostringstream ostr;
          ostr << "ModeratorPrivilegeRecord::granted_by: failed to convert 'granted_by' field data"
            " to unsigned long long";

          throw Exception(ostr.str());
        }
      }

      return El::MySQL::UnsignedLongLong(is_null, value);
    }

    inline
    El::MySQL::String
    ModeratorPrivilegeRecord::args() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("ModeratorPrivilegeRecord::args: row_ is 0");
      }

      if(3 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "ModeratorPrivilegeRecord::args: unexpected index 3 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[3] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[3], lengths[3]);

      return tmp;
    }

  }
}

#endif // _NEWSGATE_MODERATION_MODERATORRECORD__2087742441_
