/*
 * product   : NewsGate - news search WEB server
 * copyright : Copyright (c) 2005-2016 Karen Arutyunov
 * licenses  : CC BY-NC-SA 3.0; see accompanying LICENSE file
 *             Commercial; contact karen.arutyunov@gmail.com
 */

// Copyright (C) 2005-2008 Karen Arutyunov
//
// This program was generated by MySQL Class Generating Compiler
// MySQLClassGen (TM)
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA

#ifndef _NEWSGATE_SEARCHMAILING_DB_SUBSCRIPTION__400539675_
#define _NEWSGATE_SEARCHMAILING_DB_SUBSCRIPTION__400539675_

#include <limits.h>

#include <string>
#include <sstream>

#include <El/Exception.hpp>
#include <El/MySQL/DB.hpp>

namespace NewsGate
{
  namespace SearchMailing
  {
    namespace DB
    {
//
// Subscription class declaration
//
      class Subscription: public El::MySQL::Row
      {
      public:
        EL_EXCEPTION(Exception, El::MySQL::Exception);
        EL_EXCEPTION(IsNull, Exception);

      public:
        Subscription(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
          throw(Exception, El::Exception);

        El::MySQL::String id() const
         throw(Exception, El::Exception);

        El::MySQL::String status() const
         throw(Exception, El::Exception);

        El::MySQL::DateTime reg_time() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLong reg_time_usec() const
         throw(Exception, El::Exception);

        El::MySQL::DateTime update_time() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLong update_time_usec() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong search_time() const
         throw(Exception, El::Exception);

        El::MySQL::String email() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedChar format() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedShort length() const
         throw(Exception, El::Exception);

        El::MySQL::Short time_offset() const
         throw(Exception, El::Exception);

        El::MySQL::String title() const
         throw(Exception, El::Exception);

        El::MySQL::String query() const
         throw(Exception, El::Exception);

        El::MySQL::String modifier() const
         throw(Exception, El::Exception);

        El::MySQL::String filter() const
         throw(Exception, El::Exception);

        El::MySQL::String res_query() const
         throw(Exception, El::Exception);

        El::MySQL::String res_filter_lang() const
         throw(Exception, El::Exception);

        El::MySQL::String res_filter_country() const
         throw(Exception, El::Exception);

        El::MySQL::String res_filter_feed() const
         throw(Exception, El::Exception);

        El::MySQL::String res_filter_category() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong res_filter_event() const
         throw(Exception, El::Exception);

        El::MySQL::String locale_lang() const
         throw(Exception, El::Exception);

        El::MySQL::String locale_country() const
         throw(Exception, El::Exception);

        El::MySQL::String lang() const
         throw(Exception, El::Exception);

        El::MySQL::String user_id() const
         throw(Exception, El::Exception);

        El::MySQL::String user_ip() const
         throw(Exception, El::Exception);

        El::MySQL::String user_agent() const
         throw(Exception, El::Exception);

        El::MySQL::String user_session() const
         throw(Exception, El::Exception);

        El::MySQL::String times() const
         throw(Exception, El::Exception);

      };

//
// Subscription class definition
//
      inline
      Subscription::Subscription(El::MySQL::Result* result, unsigned long use_columns)
        throw(Exception, El::Exception)
          : Row(result)
      {
        unsigned long num_columns = std::min(use_columns, (unsigned long)29);

        if(result->num_fields() != num_columns)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected number of fields "
               << result->num_fields() << " instead of " << num_columns;

          throw Exception(ostr.str());
        }

        if(use_columns >= 0)
        {
          return;
        }

        enum_field_types type = (*result)[0].type;

        if(type != 254)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 254 for field id";

          throw Exception(ostr.str());
        }

        unsigned int flags = 
          (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field id";

          throw Exception(ostr.str());
        }

        const char* name = (*result)[0].name;

        if(strcmp(name, "id"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of id for field id";

          throw Exception(ostr.str());
        }

        if(use_columns >= 1)
        {
          return;
        }

        type = (*result)[1].type;

        if(type != 254)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 254 for field status";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field status";

          throw Exception(ostr.str());
        }

        name = (*result)[1].name;

        if(strcmp(name, "status"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of status for field status";

          throw Exception(ostr.str());
        }

        if(use_columns >= 2)
        {
          return;
        }

        type = (*result)[2].type;

        if(type != 12)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 12 for field reg_time";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x81)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x81 for field reg_time";

          throw Exception(ostr.str());
        }

        name = (*result)[2].name;

        if(strcmp(name, "reg_time"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of reg_time for field reg_time";

          throw Exception(ostr.str());
        }

        if(use_columns >= 3)
        {
          return;
        }

        type = (*result)[3].type;

        if(type != 9)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 9 for field reg_time_usec";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[3].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field reg_time_usec";

          throw Exception(ostr.str());
        }

        name = (*result)[3].name;

        if(strcmp(name, "reg_time_usec"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of reg_time_usec for field reg_time_usec";

          throw Exception(ostr.str());
        }

        if(use_columns >= 4)
        {
          return;
        }

        type = (*result)[4].type;

        if(type != 12)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 12 for field update_time";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[4].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x81)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x81 for field update_time";

          throw Exception(ostr.str());
        }

        name = (*result)[4].name;

        if(strcmp(name, "update_time"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of update_time for field update_time";

          throw Exception(ostr.str());
        }

        if(use_columns >= 5)
        {
          return;
        }

        type = (*result)[5].type;

        if(type != 9)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 9 for field update_time_usec";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[5].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field update_time_usec";

          throw Exception(ostr.str());
        }

        name = (*result)[5].name;

        if(strcmp(name, "update_time_usec"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of update_time_usec for field update_time_usec";

          throw Exception(ostr.str());
        }

        if(use_columns >= 6)
        {
          return;
        }

        type = (*result)[6].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 8 for field search_time";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[6].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field search_time";

          throw Exception(ostr.str());
        }

        name = (*result)[6].name;

        if(strcmp(name, "search_time"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of search_time for field search_time";

          throw Exception(ostr.str());
        }

        if(use_columns >= 7)
        {
          return;
        }

        type = (*result)[7].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 253 for field email";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[7].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x81)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x81 for field email";

          throw Exception(ostr.str());
        }

        name = (*result)[7].name;

        if(strcmp(name, "email"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of email for field email";

          throw Exception(ostr.str());
        }

        if(use_columns >= 8)
        {
          return;
        }

        type = (*result)[8].type;

        if(type != 1)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 1 for field format";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[8].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field format";

          throw Exception(ostr.str());
        }

        name = (*result)[8].name;

        if(strcmp(name, "format"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of format for field format";

          throw Exception(ostr.str());
        }

        if(use_columns >= 9)
        {
          return;
        }

        type = (*result)[9].type;

        if(type != 2)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 2 for field length";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[9].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field length";

          throw Exception(ostr.str());
        }

        name = (*result)[9].name;

        if(strcmp(name, "length"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of length for field length";

          throw Exception(ostr.str());
        }

        if(use_columns >= 10)
        {
          return;
        }

        type = (*result)[10].type;

        if(type != 2)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 2 for field time_offset";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[10].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field time_offset";

          throw Exception(ostr.str());
        }

        name = (*result)[10].name;

        if(strcmp(name, "time_offset"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of time_offset for field time_offset";

          throw Exception(ostr.str());
        }

        if(use_columns >= 11)
        {
          return;
        }

        type = (*result)[11].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 252 for field title";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[11].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field title";

          throw Exception(ostr.str());
        }

        name = (*result)[11].name;

        if(strcmp(name, "title"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of title for field title";

          throw Exception(ostr.str());
        }

        if(use_columns >= 12)
        {
          return;
        }

        type = (*result)[12].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 252 for field query";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[12].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field query";

          throw Exception(ostr.str());
        }

        name = (*result)[12].name;

        if(strcmp(name, "query"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of query for field query";

          throw Exception(ostr.str());
        }

        if(use_columns >= 13)
        {
          return;
        }

        type = (*result)[13].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 252 for field modifier";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[13].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x81)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x81 for field modifier";

          throw Exception(ostr.str());
        }

        name = (*result)[13].name;

        if(strcmp(name, "modifier"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of modifier for field modifier";

          throw Exception(ostr.str());
        }

        if(use_columns >= 14)
        {
          return;
        }

        type = (*result)[14].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 252 for field filter";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[14].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x81)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x81 for field filter";

          throw Exception(ostr.str());
        }

        name = (*result)[14].name;

        if(strcmp(name, "filter"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of filter for field filter";

          throw Exception(ostr.str());
        }

        if(use_columns >= 15)
        {
          return;
        }

        type = (*result)[15].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 252 for field res_query";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[15].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field res_query";

          throw Exception(ostr.str());
        }

        name = (*result)[15].name;

        if(strcmp(name, "res_query"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of res_query for field res_query";

          throw Exception(ostr.str());
        }

        if(use_columns >= 16)
        {
          return;
        }

        type = (*result)[16].type;

        if(type != 254)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 254 for field res_filter_lang";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[16].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field res_filter_lang";

          throw Exception(ostr.str());
        }

        name = (*result)[16].name;

        if(strcmp(name, "res_filter_lang"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of res_filter_lang for field res_filter_lang";

          throw Exception(ostr.str());
        }

        if(use_columns >= 17)
        {
          return;
        }

        type = (*result)[17].type;

        if(type != 254)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 254 for field res_filter_country";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[17].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field res_filter_country";

          throw Exception(ostr.str());
        }

        name = (*result)[17].name;

        if(strcmp(name, "res_filter_country"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of res_filter_country for field res_filter_country";

          throw Exception(ostr.str());
        }

        if(use_columns >= 18)
        {
          return;
        }

        type = (*result)[18].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 253 for field res_filter_feed";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[18].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field res_filter_feed";

          throw Exception(ostr.str());
        }

        name = (*result)[18].name;

        if(strcmp(name, "res_filter_feed"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of res_filter_feed for field res_filter_feed";

          throw Exception(ostr.str());
        }

        if(use_columns >= 19)
        {
          return;
        }

        type = (*result)[19].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 253 for field res_filter_category";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[19].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field res_filter_category";

          throw Exception(ostr.str());
        }

        name = (*result)[19].name;

        if(strcmp(name, "res_filter_category"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of res_filter_category for field res_filter_category";

          throw Exception(ostr.str());
        }

        if(use_columns >= 20)
        {
          return;
        }

        type = (*result)[20].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 8 for field res_filter_event";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[20].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field res_filter_event";

          throw Exception(ostr.str());
        }

        name = (*result)[20].name;

        if(strcmp(name, "res_filter_event"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of res_filter_event for field res_filter_event";

          throw Exception(ostr.str());
        }

        if(use_columns >= 21)
        {
          return;
        }

        type = (*result)[21].type;

        if(type != 254)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 254 for field locale_lang";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[21].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field locale_lang";

          throw Exception(ostr.str());
        }

        name = (*result)[21].name;

        if(strcmp(name, "locale_lang"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of locale_lang for field locale_lang";

          throw Exception(ostr.str());
        }

        if(use_columns >= 22)
        {
          return;
        }

        type = (*result)[22].type;

        if(type != 254)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 254 for field locale_country";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[22].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field locale_country";

          throw Exception(ostr.str());
        }

        name = (*result)[22].name;

        if(strcmp(name, "locale_country"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of locale_country for field locale_country";

          throw Exception(ostr.str());
        }

        if(use_columns >= 23)
        {
          return;
        }

        type = (*result)[23].type;

        if(type != 254)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 254 for field lang";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[23].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field lang";

          throw Exception(ostr.str());
        }

        name = (*result)[23].name;

        if(strcmp(name, "lang"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of lang for field lang";

          throw Exception(ostr.str());
        }

        if(use_columns >= 24)
        {
          return;
        }

        type = (*result)[24].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 253 for field user_id";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[24].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field user_id";

          throw Exception(ostr.str());
        }

        name = (*result)[24].name;

        if(strcmp(name, "user_id"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of user_id for field user_id";

          throw Exception(ostr.str());
        }

        if(use_columns >= 25)
        {
          return;
        }

        type = (*result)[25].type;

        if(type != 254)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 254 for field user_ip";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[25].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field user_ip";

          throw Exception(ostr.str());
        }

        name = (*result)[25].name;

        if(strcmp(name, "user_ip"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of user_ip for field user_ip";

          throw Exception(ostr.str());
        }

        if(use_columns >= 26)
        {
          return;
        }

        type = (*result)[26].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 253 for field user_agent";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[26].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field user_agent";

          throw Exception(ostr.str());
        }

        name = (*result)[26].name;

        if(strcmp(name, "user_agent"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of user_agent for field user_agent";

          throw Exception(ostr.str());
        }

        if(use_columns >= 27)
        {
          return;
        }

        type = (*result)[27].type;

        if(type != 254)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 254 for field user_session";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[27].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field user_session";

          throw Exception(ostr.str());
        }

        name = (*result)[27].name;

        if(strcmp(name, "user_session"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of user_session for field user_session";

          throw Exception(ostr.str());
        }

        if(use_columns >= 28)
        {
          return;
        }

        type = (*result)[28].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected type " << type
               << " instead of 252 for field times";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[28].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x81)
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected flags 0x" << std::hex
               << flags << " instead of 0x81 for field times";

          throw Exception(ostr.str());
        }

        name = (*result)[28].name;

        if(strcmp(name, "times"))
        {
          std::ostringstream ostr;
          ostr << "Subscription::Subscription: unexpected name " << name
               << " instead of times for field times";

          throw Exception(ostr.str());
        }

      }

      inline
      El::MySQL::String
      Subscription::id() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::id: row_ is 0");
        }

        if(0 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::id: unexpected index 0 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[0] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[0], lengths[0]);

        return tmp;
      }

      inline
      El::MySQL::String
      Subscription::status() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::status: row_ is 0");
        }

        if(1 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::status: unexpected index 1 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[1] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[1], lengths[1]);

        return tmp;
      }

      inline
      El::MySQL::DateTime
      Subscription::reg_time() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::reg_time: row_ is 0");
        }

        if(2 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::reg_time: unexpected index 2 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[2] == 0)
        {
          El::MySQL::DateTime tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::DateTime tmp(false, row_[2], lengths[2]);

        return tmp;
      }

      inline
      El::MySQL::UnsignedLong
      Subscription::reg_time_usec() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::reg_time_usec: row_ is 0");
        }

        if(3 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::reg_time_usec: unexpected index 3 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long value = 0;
        bool is_null = row_[3] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[3], lengths[3]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "Subscription::reg_time_usec: failed to convert 'reg_time_usec' field data"
              " to unsigned long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLong(is_null, value);
      }

      inline
      El::MySQL::DateTime
      Subscription::update_time() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::update_time: row_ is 0");
        }

        if(4 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::update_time: unexpected index 4 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[4] == 0)
        {
          El::MySQL::DateTime tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::DateTime tmp(false, row_[4], lengths[4]);

        return tmp;
      }

      inline
      El::MySQL::UnsignedLong
      Subscription::update_time_usec() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::update_time_usec: row_ is 0");
        }

        if(5 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::update_time_usec: unexpected index 5 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long value = 0;
        bool is_null = row_[5] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[5], lengths[5]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "Subscription::update_time_usec: failed to convert 'update_time_usec' field data"
              " to unsigned long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLong(is_null, value);
      }

      inline
      El::MySQL::UnsignedLongLong
      Subscription::search_time() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::search_time: row_ is 0");
        }

        if(6 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::search_time: unexpected index 6 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[6] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[6], lengths[6]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "Subscription::search_time: failed to convert 'search_time' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::String
      Subscription::email() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::email: row_ is 0");
        }

        if(7 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::email: unexpected index 7 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[7] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[7], lengths[7]);

        return tmp;
      }

      inline
      El::MySQL::UnsignedChar
      Subscription::format() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::format: row_ is 0");
        }

        if(8 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::format: unexpected index 8 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned short value = 0;
        bool is_null = row_[8] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[8], lengths[8]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "Subscription::format: failed to convert 'format' field data"
              " to unsigned short";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedChar(is_null, value);
      }

      inline
      El::MySQL::UnsignedShort
      Subscription::length() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::length: row_ is 0");
        }

        if(9 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::length: unexpected index 9 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned short value = 0;
        bool is_null = row_[9] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[9], lengths[9]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "Subscription::length: failed to convert 'length' field data"
              " to unsigned short";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedShort(is_null, value);
      }

      inline
      El::MySQL::Short
      Subscription::time_offset() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::time_offset: row_ is 0");
        }

        if(10 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::time_offset: unexpected index 10 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        short value = 0;
        bool is_null = row_[10] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[10], lengths[10]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "Subscription::time_offset: failed to convert 'time_offset' field data"
              " to short";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::Short(is_null, value);
      }

      inline
      El::MySQL::String
      Subscription::title() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::title: row_ is 0");
        }

        if(11 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::title: unexpected index 11 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[11] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[11], lengths[11]);

        return tmp;
      }

      inline
      El::MySQL::String
      Subscription::query() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::query: row_ is 0");
        }

        if(12 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::query: unexpected index 12 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[12] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[12], lengths[12]);

        return tmp;
      }

      inline
      El::MySQL::String
      Subscription::modifier() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::modifier: row_ is 0");
        }

        if(13 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::modifier: unexpected index 13 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[13] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[13], lengths[13]);

        return tmp;
      }

      inline
      El::MySQL::String
      Subscription::filter() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::filter: row_ is 0");
        }

        if(14 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::filter: unexpected index 14 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[14] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[14], lengths[14]);

        return tmp;
      }

      inline
      El::MySQL::String
      Subscription::res_query() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::res_query: row_ is 0");
        }

        if(15 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::res_query: unexpected index 15 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[15] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[15], lengths[15]);

        return tmp;
      }

      inline
      El::MySQL::String
      Subscription::res_filter_lang() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::res_filter_lang: row_ is 0");
        }

        if(16 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::res_filter_lang: unexpected index 16 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[16] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[16], lengths[16]);

        return tmp;
      }

      inline
      El::MySQL::String
      Subscription::res_filter_country() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::res_filter_country: row_ is 0");
        }

        if(17 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::res_filter_country: unexpected index 17 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[17] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[17], lengths[17]);

        return tmp;
      }

      inline
      El::MySQL::String
      Subscription::res_filter_feed() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::res_filter_feed: row_ is 0");
        }

        if(18 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::res_filter_feed: unexpected index 18 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[18] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[18], lengths[18]);

        return tmp;
      }

      inline
      El::MySQL::String
      Subscription::res_filter_category() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::res_filter_category: row_ is 0");
        }

        if(19 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::res_filter_category: unexpected index 19 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[19] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[19], lengths[19]);

        return tmp;
      }

      inline
      El::MySQL::UnsignedLongLong
      Subscription::res_filter_event() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::res_filter_event: row_ is 0");
        }

        if(20 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::res_filter_event: unexpected index 20 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[20] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[20], lengths[20]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "Subscription::res_filter_event: failed to convert 'res_filter_event' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::String
      Subscription::locale_lang() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::locale_lang: row_ is 0");
        }

        if(21 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::locale_lang: unexpected index 21 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[21] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[21], lengths[21]);

        return tmp;
      }

      inline
      El::MySQL::String
      Subscription::locale_country() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::locale_country: row_ is 0");
        }

        if(22 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::locale_country: unexpected index 22 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[22] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[22], lengths[22]);

        return tmp;
      }

      inline
      El::MySQL::String
      Subscription::lang() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::lang: row_ is 0");
        }

        if(23 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::lang: unexpected index 23 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[23] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[23], lengths[23]);

        return tmp;
      }

      inline
      El::MySQL::String
      Subscription::user_id() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::user_id: row_ is 0");
        }

        if(24 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::user_id: unexpected index 24 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[24] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[24], lengths[24]);

        return tmp;
      }

      inline
      El::MySQL::String
      Subscription::user_ip() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::user_ip: row_ is 0");
        }

        if(25 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::user_ip: unexpected index 25 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[25] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[25], lengths[25]);

        return tmp;
      }

      inline
      El::MySQL::String
      Subscription::user_agent() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::user_agent: row_ is 0");
        }

        if(26 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::user_agent: unexpected index 26 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[26] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[26], lengths[26]);

        return tmp;
      }

      inline
      El::MySQL::String
      Subscription::user_session() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::user_session: row_ is 0");
        }

        if(27 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::user_session: unexpected index 27 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[27] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[27], lengths[27]);

        return tmp;
      }

      inline
      El::MySQL::String
      Subscription::times() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("Subscription::times: row_ is 0");
        }

        if(28 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "Subscription::times: unexpected index 28 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[28] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[28], lengths[28]);

        return tmp;
      }

    }
  }
}

namespace NewsGate
{
  namespace SearchMailing
  {
    namespace DB
    {
//
// SubscriptionUpdate class declaration
//
      class SubscriptionUpdate: public El::MySQL::Row
      {
      public:
        EL_EXCEPTION(Exception, El::MySQL::Exception);
        EL_EXCEPTION(IsNull, Exception);

      public:
        SubscriptionUpdate(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
          throw(Exception, El::Exception);

        El::MySQL::String token() const
         throw(Exception, El::Exception);

        El::MySQL::String state() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedChar type() const
         throw(Exception, El::Exception);

        El::MySQL::String conf_email() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong conf_time() const
         throw(Exception, El::Exception);

        El::MySQL::String id() const
         throw(Exception, El::Exception);

        El::MySQL::String status() const
         throw(Exception, El::Exception);

        El::MySQL::DateTime req_time() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLong req_time_usec() const
         throw(Exception, El::Exception);

        El::MySQL::String email() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedChar format() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedShort length() const
         throw(Exception, El::Exception);

        El::MySQL::Short time_offset() const
         throw(Exception, El::Exception);

        El::MySQL::String title() const
         throw(Exception, El::Exception);

        El::MySQL::String query() const
         throw(Exception, El::Exception);

        El::MySQL::String modifier() const
         throw(Exception, El::Exception);

        El::MySQL::String filter() const
         throw(Exception, El::Exception);

        El::MySQL::String res_query() const
         throw(Exception, El::Exception);

        El::MySQL::String res_filter_lang() const
         throw(Exception, El::Exception);

        El::MySQL::String res_filter_country() const
         throw(Exception, El::Exception);

        El::MySQL::String res_filter_feed() const
         throw(Exception, El::Exception);

        El::MySQL::String res_filter_category() const
         throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong res_filter_event() const
         throw(Exception, El::Exception);

        El::MySQL::String locale_lang() const
         throw(Exception, El::Exception);

        El::MySQL::String locale_country() const
         throw(Exception, El::Exception);

        El::MySQL::String lang() const
         throw(Exception, El::Exception);

        El::MySQL::String user_id() const
         throw(Exception, El::Exception);

        El::MySQL::String user_ip() const
         throw(Exception, El::Exception);

        El::MySQL::String user_agent() const
         throw(Exception, El::Exception);

        El::MySQL::String user_session() const
         throw(Exception, El::Exception);

        El::MySQL::String times() const
         throw(Exception, El::Exception);

      };

//
// SubscriptionUpdate class definition
//
      inline
      SubscriptionUpdate::SubscriptionUpdate(El::MySQL::Result* result, unsigned long use_columns)
        throw(Exception, El::Exception)
          : Row(result)
      {
        unsigned long num_columns = std::min(use_columns, (unsigned long)31);

        if(result->num_fields() != num_columns)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected number of fields "
               << result->num_fields() << " instead of " << num_columns;

          throw Exception(ostr.str());
        }

        if(use_columns >= 0)
        {
          return;
        }

        enum_field_types type = (*result)[0].type;

        if(type != 254)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 254 for field token";

          throw Exception(ostr.str());
        }

        unsigned int flags = 
          (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field token";

          throw Exception(ostr.str());
        }

        const char* name = (*result)[0].name;

        if(strcmp(name, "token"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of token for field token";

          throw Exception(ostr.str());
        }

        if(use_columns >= 1)
        {
          return;
        }

        type = (*result)[1].type;

        if(type != 254)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 254 for field state";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field state";

          throw Exception(ostr.str());
        }

        name = (*result)[1].name;

        if(strcmp(name, "state"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of state for field state";

          throw Exception(ostr.str());
        }

        if(use_columns >= 2)
        {
          return;
        }

        type = (*result)[2].type;

        if(type != 1)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 1 for field type";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field type";

          throw Exception(ostr.str());
        }

        name = (*result)[2].name;

        if(strcmp(name, "type"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of type for field type";

          throw Exception(ostr.str());
        }

        if(use_columns >= 3)
        {
          return;
        }

        type = (*result)[3].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 253 for field conf_email";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[3].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x81)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x81 for field conf_email";

          throw Exception(ostr.str());
        }

        name = (*result)[3].name;

        if(strcmp(name, "conf_email"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of conf_email for field conf_email";

          throw Exception(ostr.str());
        }

        if(use_columns >= 4)
        {
          return;
        }

        type = (*result)[4].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 8 for field conf_time";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[4].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field conf_time";

          throw Exception(ostr.str());
        }

        name = (*result)[4].name;

        if(strcmp(name, "conf_time"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of conf_time for field conf_time";

          throw Exception(ostr.str());
        }

        if(use_columns >= 5)
        {
          return;
        }

        type = (*result)[5].type;

        if(type != 254)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 254 for field id";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[5].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field id";

          throw Exception(ostr.str());
        }

        name = (*result)[5].name;

        if(strcmp(name, "id"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of id for field id";

          throw Exception(ostr.str());
        }

        if(use_columns >= 6)
        {
          return;
        }

        type = (*result)[6].type;

        if(type != 254)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 254 for field status";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[6].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field status";

          throw Exception(ostr.str());
        }

        name = (*result)[6].name;

        if(strcmp(name, "status"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of status for field status";

          throw Exception(ostr.str());
        }

        if(use_columns >= 7)
        {
          return;
        }

        type = (*result)[7].type;

        if(type != 12)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 12 for field req_time";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[7].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x81)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x81 for field req_time";

          throw Exception(ostr.str());
        }

        name = (*result)[7].name;

        if(strcmp(name, "req_time"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of req_time for field req_time";

          throw Exception(ostr.str());
        }

        if(use_columns >= 8)
        {
          return;
        }

        type = (*result)[8].type;

        if(type != 9)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 9 for field req_time_usec";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[8].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field req_time_usec";

          throw Exception(ostr.str());
        }

        name = (*result)[8].name;

        if(strcmp(name, "req_time_usec"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of req_time_usec for field req_time_usec";

          throw Exception(ostr.str());
        }

        if(use_columns >= 9)
        {
          return;
        }

        type = (*result)[9].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 253 for field email";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[9].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x81)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x81 for field email";

          throw Exception(ostr.str());
        }

        name = (*result)[9].name;

        if(strcmp(name, "email"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of email for field email";

          throw Exception(ostr.str());
        }

        if(use_columns >= 10)
        {
          return;
        }

        type = (*result)[10].type;

        if(type != 1)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 1 for field format";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[10].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field format";

          throw Exception(ostr.str());
        }

        name = (*result)[10].name;

        if(strcmp(name, "format"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of format for field format";

          throw Exception(ostr.str());
        }

        if(use_columns >= 11)
        {
          return;
        }

        type = (*result)[11].type;

        if(type != 2)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 2 for field length";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[11].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field length";

          throw Exception(ostr.str());
        }

        name = (*result)[11].name;

        if(strcmp(name, "length"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of length for field length";

          throw Exception(ostr.str());
        }

        if(use_columns >= 12)
        {
          return;
        }

        type = (*result)[12].type;

        if(type != 2)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 2 for field time_offset";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[12].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field time_offset";

          throw Exception(ostr.str());
        }

        name = (*result)[12].name;

        if(strcmp(name, "time_offset"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of time_offset for field time_offset";

          throw Exception(ostr.str());
        }

        if(use_columns >= 13)
        {
          return;
        }

        type = (*result)[13].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 252 for field title";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[13].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field title";

          throw Exception(ostr.str());
        }

        name = (*result)[13].name;

        if(strcmp(name, "title"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of title for field title";

          throw Exception(ostr.str());
        }

        if(use_columns >= 14)
        {
          return;
        }

        type = (*result)[14].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 252 for field query";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[14].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field query";

          throw Exception(ostr.str());
        }

        name = (*result)[14].name;

        if(strcmp(name, "query"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of query for field query";

          throw Exception(ostr.str());
        }

        if(use_columns >= 15)
        {
          return;
        }

        type = (*result)[15].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 252 for field modifier";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[15].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x81)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x81 for field modifier";

          throw Exception(ostr.str());
        }

        name = (*result)[15].name;

        if(strcmp(name, "modifier"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of modifier for field modifier";

          throw Exception(ostr.str());
        }

        if(use_columns >= 16)
        {
          return;
        }

        type = (*result)[16].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 252 for field filter";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[16].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x81)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x81 for field filter";

          throw Exception(ostr.str());
        }

        name = (*result)[16].name;

        if(strcmp(name, "filter"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of filter for field filter";

          throw Exception(ostr.str());
        }

        if(use_columns >= 17)
        {
          return;
        }

        type = (*result)[17].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 252 for field res_query";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[17].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field res_query";

          throw Exception(ostr.str());
        }

        name = (*result)[17].name;

        if(strcmp(name, "res_query"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of res_query for field res_query";

          throw Exception(ostr.str());
        }

        if(use_columns >= 18)
        {
          return;
        }

        type = (*result)[18].type;

        if(type != 254)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 254 for field res_filter_lang";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[18].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field res_filter_lang";

          throw Exception(ostr.str());
        }

        name = (*result)[18].name;

        if(strcmp(name, "res_filter_lang"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of res_filter_lang for field res_filter_lang";

          throw Exception(ostr.str());
        }

        if(use_columns >= 19)
        {
          return;
        }

        type = (*result)[19].type;

        if(type != 254)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 254 for field res_filter_country";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[19].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field res_filter_country";

          throw Exception(ostr.str());
        }

        name = (*result)[19].name;

        if(strcmp(name, "res_filter_country"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of res_filter_country for field res_filter_country";

          throw Exception(ostr.str());
        }

        if(use_columns >= 20)
        {
          return;
        }

        type = (*result)[20].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 253 for field res_filter_feed";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[20].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field res_filter_feed";

          throw Exception(ostr.str());
        }

        name = (*result)[20].name;

        if(strcmp(name, "res_filter_feed"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of res_filter_feed for field res_filter_feed";

          throw Exception(ostr.str());
        }

        if(use_columns >= 21)
        {
          return;
        }

        type = (*result)[21].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 253 for field res_filter_category";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[21].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field res_filter_category";

          throw Exception(ostr.str());
        }

        name = (*result)[21].name;

        if(strcmp(name, "res_filter_category"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of res_filter_category for field res_filter_category";

          throw Exception(ostr.str());
        }

        if(use_columns >= 22)
        {
          return;
        }

        type = (*result)[22].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 8 for field res_filter_event";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[22].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field res_filter_event";

          throw Exception(ostr.str());
        }

        name = (*result)[22].name;

        if(strcmp(name, "res_filter_event"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of res_filter_event for field res_filter_event";

          throw Exception(ostr.str());
        }

        if(use_columns >= 23)
        {
          return;
        }

        type = (*result)[23].type;

        if(type != 254)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 254 for field locale_lang";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[23].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field locale_lang";

          throw Exception(ostr.str());
        }

        name = (*result)[23].name;

        if(strcmp(name, "locale_lang"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of locale_lang for field locale_lang";

          throw Exception(ostr.str());
        }

        if(use_columns >= 24)
        {
          return;
        }

        type = (*result)[24].type;

        if(type != 254)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 254 for field locale_country";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[24].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field locale_country";

          throw Exception(ostr.str());
        }

        name = (*result)[24].name;

        if(strcmp(name, "locale_country"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of locale_country for field locale_country";

          throw Exception(ostr.str());
        }

        if(use_columns >= 25)
        {
          return;
        }

        type = (*result)[25].type;

        if(type != 254)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 254 for field lang";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[25].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field lang";

          throw Exception(ostr.str());
        }

        name = (*result)[25].name;

        if(strcmp(name, "lang"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of lang for field lang";

          throw Exception(ostr.str());
        }

        if(use_columns >= 26)
        {
          return;
        }

        type = (*result)[26].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 253 for field user_id";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[26].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field user_id";

          throw Exception(ostr.str());
        }

        name = (*result)[26].name;

        if(strcmp(name, "user_id"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of user_id for field user_id";

          throw Exception(ostr.str());
        }

        if(use_columns >= 27)
        {
          return;
        }

        type = (*result)[27].type;

        if(type != 254)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 254 for field user_ip";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[27].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field user_ip";

          throw Exception(ostr.str());
        }

        name = (*result)[27].name;

        if(strcmp(name, "user_ip"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of user_ip for field user_ip";

          throw Exception(ostr.str());
        }

        if(use_columns >= 28)
        {
          return;
        }

        type = (*result)[28].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 253 for field user_agent";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[28].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field user_agent";

          throw Exception(ostr.str());
        }

        name = (*result)[28].name;

        if(strcmp(name, "user_agent"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of user_agent for field user_agent";

          throw Exception(ostr.str());
        }

        if(use_columns >= 29)
        {
          return;
        }

        type = (*result)[29].type;

        if(type != 254)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 254 for field user_session";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[29].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field user_session";

          throw Exception(ostr.str());
        }

        name = (*result)[29].name;

        if(strcmp(name, "user_session"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of user_session for field user_session";

          throw Exception(ostr.str());
        }

        if(use_columns >= 30)
        {
          return;
        }

        type = (*result)[30].type;

        if(type != 252)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected type " << type
               << " instead of 252 for field times";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[30].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x81)
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected flags 0x" << std::hex
               << flags << " instead of 0x81 for field times";

          throw Exception(ostr.str());
        }

        name = (*result)[30].name;

        if(strcmp(name, "times"))
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::SubscriptionUpdate: unexpected name " << name
               << " instead of times for field times";

          throw Exception(ostr.str());
        }

      }

      inline
      El::MySQL::String
      SubscriptionUpdate::token() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::token: row_ is 0");
        }

        if(0 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::token: unexpected index 0 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[0] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[0], lengths[0]);

        return tmp;
      }

      inline
      El::MySQL::String
      SubscriptionUpdate::state() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::state: row_ is 0");
        }

        if(1 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::state: unexpected index 1 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[1] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[1], lengths[1]);

        return tmp;
      }

      inline
      El::MySQL::UnsignedChar
      SubscriptionUpdate::type() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::type: row_ is 0");
        }

        if(2 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::type: unexpected index 2 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned short value = 0;
        bool is_null = row_[2] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[2], lengths[2]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "SubscriptionUpdate::type: failed to convert 'type' field data"
              " to unsigned short";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedChar(is_null, value);
      }

      inline
      El::MySQL::String
      SubscriptionUpdate::conf_email() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::conf_email: row_ is 0");
        }

        if(3 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::conf_email: unexpected index 3 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[3] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[3], lengths[3]);

        return tmp;
      }

      inline
      El::MySQL::UnsignedLongLong
      SubscriptionUpdate::conf_time() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::conf_time: row_ is 0");
        }

        if(4 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::conf_time: unexpected index 4 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[4] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[4], lengths[4]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "SubscriptionUpdate::conf_time: failed to convert 'conf_time' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::String
      SubscriptionUpdate::id() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::id: row_ is 0");
        }

        if(5 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::id: unexpected index 5 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[5] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[5], lengths[5]);

        return tmp;
      }

      inline
      El::MySQL::String
      SubscriptionUpdate::status() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::status: row_ is 0");
        }

        if(6 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::status: unexpected index 6 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[6] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[6], lengths[6]);

        return tmp;
      }

      inline
      El::MySQL::DateTime
      SubscriptionUpdate::req_time() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::req_time: row_ is 0");
        }

        if(7 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::req_time: unexpected index 7 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[7] == 0)
        {
          El::MySQL::DateTime tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::DateTime tmp(false, row_[7], lengths[7]);

        return tmp;
      }

      inline
      El::MySQL::UnsignedLong
      SubscriptionUpdate::req_time_usec() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::req_time_usec: row_ is 0");
        }

        if(8 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::req_time_usec: unexpected index 8 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long value = 0;
        bool is_null = row_[8] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[8], lengths[8]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "SubscriptionUpdate::req_time_usec: failed to convert 'req_time_usec' field data"
              " to unsigned long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLong(is_null, value);
      }

      inline
      El::MySQL::String
      SubscriptionUpdate::email() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::email: row_ is 0");
        }

        if(9 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::email: unexpected index 9 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[9] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[9], lengths[9]);

        return tmp;
      }

      inline
      El::MySQL::UnsignedChar
      SubscriptionUpdate::format() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::format: row_ is 0");
        }

        if(10 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::format: unexpected index 10 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned short value = 0;
        bool is_null = row_[10] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[10], lengths[10]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "SubscriptionUpdate::format: failed to convert 'format' field data"
              " to unsigned short";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedChar(is_null, value);
      }

      inline
      El::MySQL::UnsignedShort
      SubscriptionUpdate::length() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::length: row_ is 0");
        }

        if(11 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::length: unexpected index 11 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned short value = 0;
        bool is_null = row_[11] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[11], lengths[11]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "SubscriptionUpdate::length: failed to convert 'length' field data"
              " to unsigned short";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedShort(is_null, value);
      }

      inline
      El::MySQL::Short
      SubscriptionUpdate::time_offset() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::time_offset: row_ is 0");
        }

        if(12 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::time_offset: unexpected index 12 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        short value = 0;
        bool is_null = row_[12] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[12], lengths[12]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "SubscriptionUpdate::time_offset: failed to convert 'time_offset' field data"
              " to short";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::Short(is_null, value);
      }

      inline
      El::MySQL::String
      SubscriptionUpdate::title() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::title: row_ is 0");
        }

        if(13 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::title: unexpected index 13 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[13] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[13], lengths[13]);

        return tmp;
      }

      inline
      El::MySQL::String
      SubscriptionUpdate::query() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::query: row_ is 0");
        }

        if(14 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::query: unexpected index 14 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[14] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[14], lengths[14]);

        return tmp;
      }

      inline
      El::MySQL::String
      SubscriptionUpdate::modifier() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::modifier: row_ is 0");
        }

        if(15 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::modifier: unexpected index 15 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[15] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[15], lengths[15]);

        return tmp;
      }

      inline
      El::MySQL::String
      SubscriptionUpdate::filter() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::filter: row_ is 0");
        }

        if(16 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::filter: unexpected index 16 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[16] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[16], lengths[16]);

        return tmp;
      }

      inline
      El::MySQL::String
      SubscriptionUpdate::res_query() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::res_query: row_ is 0");
        }

        if(17 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::res_query: unexpected index 17 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[17] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[17], lengths[17]);

        return tmp;
      }

      inline
      El::MySQL::String
      SubscriptionUpdate::res_filter_lang() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::res_filter_lang: row_ is 0");
        }

        if(18 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::res_filter_lang: unexpected index 18 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[18] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[18], lengths[18]);

        return tmp;
      }

      inline
      El::MySQL::String
      SubscriptionUpdate::res_filter_country() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::res_filter_country: row_ is 0");
        }

        if(19 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::res_filter_country: unexpected index 19 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[19] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[19], lengths[19]);

        return tmp;
      }

      inline
      El::MySQL::String
      SubscriptionUpdate::res_filter_feed() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::res_filter_feed: row_ is 0");
        }

        if(20 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::res_filter_feed: unexpected index 20 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[20] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[20], lengths[20]);

        return tmp;
      }

      inline
      El::MySQL::String
      SubscriptionUpdate::res_filter_category() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::res_filter_category: row_ is 0");
        }

        if(21 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::res_filter_category: unexpected index 21 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[21] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[21], lengths[21]);

        return tmp;
      }

      inline
      El::MySQL::UnsignedLongLong
      SubscriptionUpdate::res_filter_event() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::res_filter_event: row_ is 0");
        }

        if(22 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::res_filter_event: unexpected index 22 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[22] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[22], lengths[22]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "SubscriptionUpdate::res_filter_event: failed to convert 'res_filter_event' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::String
      SubscriptionUpdate::locale_lang() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::locale_lang: row_ is 0");
        }

        if(23 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::locale_lang: unexpected index 23 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[23] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[23], lengths[23]);

        return tmp;
      }

      inline
      El::MySQL::String
      SubscriptionUpdate::locale_country() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::locale_country: row_ is 0");
        }

        if(24 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::locale_country: unexpected index 24 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[24] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[24], lengths[24]);

        return tmp;
      }

      inline
      El::MySQL::String
      SubscriptionUpdate::lang() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::lang: row_ is 0");
        }

        if(25 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::lang: unexpected index 25 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[25] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[25], lengths[25]);

        return tmp;
      }

      inline
      El::MySQL::String
      SubscriptionUpdate::user_id() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::user_id: row_ is 0");
        }

        if(26 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::user_id: unexpected index 26 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[26] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[26], lengths[26]);

        return tmp;
      }

      inline
      El::MySQL::String
      SubscriptionUpdate::user_ip() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::user_ip: row_ is 0");
        }

        if(27 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::user_ip: unexpected index 27 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[27] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[27], lengths[27]);

        return tmp;
      }

      inline
      El::MySQL::String
      SubscriptionUpdate::user_agent() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::user_agent: row_ is 0");
        }

        if(28 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::user_agent: unexpected index 28 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[28] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[28], lengths[28]);

        return tmp;
      }

      inline
      El::MySQL::String
      SubscriptionUpdate::user_session() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::user_session: row_ is 0");
        }

        if(29 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::user_session: unexpected index 29 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[29] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[29], lengths[29]);

        return tmp;
      }

      inline
      El::MySQL::String
      SubscriptionUpdate::times() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("SubscriptionUpdate::times: row_ is 0");
        }

        if(30 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "SubscriptionUpdate::times: unexpected index 30 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[30] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[30], lengths[30]);

        return tmp;
      }

    }
  }
}

namespace NewsGate
{
  namespace SearchMailing
  {
    namespace DB
    {
//
// MailState class declaration
//
      class MailState: public El::MySQL::Row
      {
      public:
        EL_EXCEPTION(Exception, El::MySQL::Exception);
        EL_EXCEPTION(IsNull, Exception);

      public:
        MailState(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
          throw(Exception, El::Exception);

        El::MySQL::UnsignedLongLong last_dispatch_time() const
         throw(Exception, El::Exception);

        El::MySQL::String mailer_id() const
         throw(Exception, El::Exception);

      };

//
// MailState class definition
//
      inline
      MailState::MailState(El::MySQL::Result* result, unsigned long use_columns)
        throw(Exception, El::Exception)
          : Row(result)
      {
        unsigned long num_columns = std::min(use_columns, (unsigned long)2);

        if(result->num_fields() != num_columns)
        {
          std::ostringstream ostr;
          ostr << "MailState::MailState: unexpected number of fields "
               << result->num_fields() << " instead of " << num_columns;

          throw Exception(ostr.str());
        }

        if(use_columns >= 0)
        {
          return;
        }

        enum_field_types type = (*result)[0].type;

        if(type != 8)
        {
          std::ostringstream ostr;
          ostr << "MailState::MailState: unexpected type " << type
               << " instead of 8 for field last_dispatch_time";

          throw Exception(ostr.str());
        }

        unsigned int flags = 
          (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x21)
        {
          std::ostringstream ostr;
          ostr << "MailState::MailState: unexpected flags 0x" << std::hex
               << flags << " instead of 0x21 for field last_dispatch_time";

          throw Exception(ostr.str());
        }

        const char* name = (*result)[0].name;

        if(strcmp(name, "last_dispatch_time"))
        {
          std::ostringstream ostr;
          ostr << "MailState::MailState: unexpected name " << name
               << " instead of last_dispatch_time for field last_dispatch_time";

          throw Exception(ostr.str());
        }

        if(use_columns >= 1)
        {
          return;
        }

        type = (*result)[1].type;

        if(type != 253)
        {
          std::ostringstream ostr;
          ostr << "MailState::MailState: unexpected type " << type
               << " instead of 253 for field mailer_id";

          throw Exception(ostr.str());
        }

        flags = 
          (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

        if(flags != 0x1)
        {
          std::ostringstream ostr;
          ostr << "MailState::MailState: unexpected flags 0x" << std::hex
               << flags << " instead of 0x1 for field mailer_id";

          throw Exception(ostr.str());
        }

        name = (*result)[1].name;

        if(strcmp(name, "mailer_id"))
        {
          std::ostringstream ostr;
          ostr << "MailState::MailState: unexpected name " << name
               << " instead of mailer_id for field mailer_id";

          throw Exception(ostr.str());
        }

      }

      inline
      El::MySQL::UnsignedLongLong
      MailState::last_dispatch_time() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("MailState::last_dispatch_time: row_ is 0");
        }

        if(0 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "MailState::last_dispatch_time: unexpected index 0 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        unsigned long long value = 0;
        bool is_null = row_[0] == 0;

        if(!is_null)
        {
          unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
          std::string tmp;
          tmp.assign(row_[0], lengths[0]);

          std::istringstream istr(tmp);
          istr >> value;

          if(istr.fail())
          {
            std::ostringstream ostr;
            ostr << "MailState::last_dispatch_time: failed to convert 'last_dispatch_time' field data"
              " to unsigned long long";

            throw Exception(ostr.str());
          }
        }

        return El::MySQL::UnsignedLongLong(is_null, value);
      }

      inline
      El::MySQL::String
      MailState::mailer_id() const
        throw(Exception, El::Exception)
      {
        El::MySQL::DB::init_thread();

        if(row_ == 0)
        {
          throw Exception("MailState::mailer_id: row_ is 0");
        }

        if(1 >= result_->num_fields())
        {
          std::ostringstream ostr;
          ostr << "MailState::mailer_id: unexpected index 1 when number of fileds is "
               << result_->num_fields();

          throw Exception(ostr.str());
        }

        if(row_[1] == 0)
        {
          El::MySQL::String tmp(true, 0, 0);
          return tmp;
        }

        unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
        El::MySQL::String tmp(false, row_[1], lengths[1]);

        return tmp;
      }

    }
  }
}

#endif // _NEWSGATE_SEARCHMAILING_DB_SUBSCRIPTION__400539675_
