/*
 * product   : NewsGate - news search WEB server
 * copyright : Copyright (c) 2005-2016 Karen Arutyunov
 * licenses  : CC BY-NC-SA 3.0; see accompanying LICENSE file
 *             Commercial; contact karen.arutyunov@gmail.com
 */

// Copyright (C) 2005-2008 Karen Arutyunov
//
// This program was generated by MySQL Class Generating Compiler
// MySQLClassGen (TM)
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA

#ifndef _NEWSGATE_MESSAGE_BANKSESSIONINFO__2087742441_
#define _NEWSGATE_MESSAGE_BANKSESSIONINFO__2087742441_

#include <limits.h>

#include <string>
#include <sstream>

#include <El/Exception.hpp>
#include <El/MySQL/DB.hpp>

namespace NewsGate
{
  namespace Message
  {
//
// BankSessionInfo class declaration
//
    class BankSessionInfo: public El::MySQL::Row
    {
    public:
      EL_EXCEPTION(Exception, El::MySQL::Exception);
      EL_EXCEPTION(IsNull, Exception);

    public:
      BankSessionInfo(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
        throw(Exception, El::Exception);

      El::MySQL::String bank_ior() const
       throw(Exception, El::Exception);

      El::MySQL::String session_id() const
       throw(Exception, El::Exception);

      El::MySQL::DateTime last_ping_time() const
       throw(Exception, El::Exception);

    };

//
// BankSessionInfo class definition
//
    inline
    BankSessionInfo::BankSessionInfo(El::MySQL::Result* result, unsigned long use_columns)
      throw(Exception, El::Exception)
        : Row(result)
    {
      unsigned long num_columns = std::min(use_columns, (unsigned long)3);

      if(result->num_fields() != num_columns)
      {
        std::ostringstream ostr;
        ostr << "BankSessionInfo::BankSessionInfo: unexpected number of fields "
             << result->num_fields() << " instead of " << num_columns;

        throw Exception(ostr.str());
      }

      if(use_columns >= 0)
      {
        return;
      }

      enum_field_types type = (*result)[0].type;

      if(type != 253)
      {
        std::ostringstream ostr;
        ostr << "BankSessionInfo::BankSessionInfo: unexpected type " << type
             << " instead of 253 for field bank_ior";

        throw Exception(ostr.str());
      }

      unsigned int flags = 
        (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

      if(flags != 0x1)
      {
        std::ostringstream ostr;
        ostr << "BankSessionInfo::BankSessionInfo: unexpected flags 0x" << std::hex
             << flags << " instead of 0x1 for field bank_ior";

        throw Exception(ostr.str());
      }

      const char* name = (*result)[0].name;

      if(strcmp(name, "bank_ior"))
      {
        std::ostringstream ostr;
        ostr << "BankSessionInfo::BankSessionInfo: unexpected name " << name
             << " instead of bank_ior for field bank_ior";

        throw Exception(ostr.str());
      }

      if(use_columns >= 1)
      {
        return;
      }

      type = (*result)[1].type;

      if(type != 253)
      {
        std::ostringstream ostr;
        ostr << "BankSessionInfo::BankSessionInfo: unexpected type " << type
             << " instead of 253 for field session_id";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[1].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

      if(flags != 0x0)
      {
        std::ostringstream ostr;
        ostr << "BankSessionInfo::BankSessionInfo: unexpected flags 0x" << std::hex
             << flags << " instead of 0x0 for field session_id";

        throw Exception(ostr.str());
      }

      name = (*result)[1].name;

      if(strcmp(name, "session_id"))
      {
        std::ostringstream ostr;
        ostr << "BankSessionInfo::BankSessionInfo: unexpected name " << name
             << " instead of session_id for field session_id";

        throw Exception(ostr.str());
      }

      if(use_columns >= 2)
      {
        return;
      }

      type = (*result)[2].type;

      if(type != 12)
      {
        std::ostringstream ostr;
        ostr << "BankSessionInfo::BankSessionInfo: unexpected type " << type
             << " instead of 12 for field last_ping_time";

        throw Exception(ostr.str());
      }

      flags = 
        (*result)[2].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

      if(flags != 0x80)
      {
        std::ostringstream ostr;
        ostr << "BankSessionInfo::BankSessionInfo: unexpected flags 0x" << std::hex
             << flags << " instead of 0x80 for field last_ping_time";

        throw Exception(ostr.str());
      }

      name = (*result)[2].name;

      if(strcmp(name, "last_ping_time"))
      {
        std::ostringstream ostr;
        ostr << "BankSessionInfo::BankSessionInfo: unexpected name " << name
             << " instead of last_ping_time for field last_ping_time";

        throw Exception(ostr.str());
      }

    }

    inline
    El::MySQL::String
    BankSessionInfo::bank_ior() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("BankSessionInfo::bank_ior: row_ is 0");
      }

      if(0 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "BankSessionInfo::bank_ior: unexpected index 0 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[0] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[0], lengths[0]);

      return tmp;
    }

    inline
    El::MySQL::String
    BankSessionInfo::session_id() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("BankSessionInfo::session_id: row_ is 0");
      }

      if(1 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "BankSessionInfo::session_id: unexpected index 1 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[1] == 0)
      {
        El::MySQL::String tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::String tmp(false, row_[1], lengths[1]);

      return tmp;
    }

    inline
    El::MySQL::DateTime
    BankSessionInfo::last_ping_time() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("BankSessionInfo::last_ping_time: row_ is 0");
      }

      if(2 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "BankSessionInfo::last_ping_time: unexpected index 2 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[2] == 0)
      {
        El::MySQL::DateTime tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::DateTime tmp(false, row_[2], lengths[2]);

      return tmp;
    }

  }
}

namespace NewsGate
{
  namespace Message
  {
//
// MessageBankManagerStateInfo class declaration
//
    class MessageBankManagerStateInfo: public El::MySQL::Row
    {
    public:
      EL_EXCEPTION(Exception, El::MySQL::Exception);
      EL_EXCEPTION(IsNull, Exception);

    public:
      MessageBankManagerStateInfo(El::MySQL::Result* result, unsigned long use_columns = ULONG_MAX)
        throw(Exception, El::Exception);

      El::MySQL::DateTime last_check_banks_presence_time() const
       throw(Exception, El::Exception);

    };

//
// MessageBankManagerStateInfo class definition
//
    inline
    MessageBankManagerStateInfo::MessageBankManagerStateInfo(El::MySQL::Result* result, unsigned long use_columns)
      throw(Exception, El::Exception)
        : Row(result)
    {
      unsigned long num_columns = std::min(use_columns, (unsigned long)1);

      if(result->num_fields() != num_columns)
      {
        std::ostringstream ostr;
        ostr << "MessageBankManagerStateInfo::MessageBankManagerStateInfo: unexpected number of fields "
             << result->num_fields() << " instead of " << num_columns;

        throw Exception(ostr.str());
      }

      if(use_columns >= 0)
      {
        return;
      }

      enum_field_types type = (*result)[0].type;

      if(type != 12)
      {
        std::ostringstream ostr;
        ostr << "MessageBankManagerStateInfo::MessageBankManagerStateInfo: unexpected type " << type
             << " instead of 12 for field last_check_banks_presence_time";

        throw Exception(ostr.str());
      }

      unsigned int flags = 
        (*result)[0].flags & (UNSIGNED_FLAG|NOT_NULL_FLAG|BINARY_FLAG);

      if(flags != 0x81)
      {
        std::ostringstream ostr;
        ostr << "MessageBankManagerStateInfo::MessageBankManagerStateInfo: unexpected flags 0x" << std::hex
             << flags << " instead of 0x81 for field last_check_banks_presence_time";

        throw Exception(ostr.str());
      }

      const char* name = (*result)[0].name;

      if(strcmp(name, "last_check_banks_presence_time"))
      {
        std::ostringstream ostr;
        ostr << "MessageBankManagerStateInfo::MessageBankManagerStateInfo: unexpected name " << name
             << " instead of last_check_banks_presence_time for field last_check_banks_presence_time";

        throw Exception(ostr.str());
      }

    }

    inline
    El::MySQL::DateTime
    MessageBankManagerStateInfo::last_check_banks_presence_time() const
      throw(Exception, El::Exception)
    {
      El::MySQL::DB::init_thread();

      if(row_ == 0)
      {
        throw Exception("MessageBankManagerStateInfo::last_check_banks_presence_time: row_ is 0");
      }

      if(0 >= result_->num_fields())
      {
        std::ostringstream ostr;
        ostr << "MessageBankManagerStateInfo::last_check_banks_presence_time: unexpected index 0 when number of fileds is "
             << result_->num_fields();

        throw Exception(ostr.str());
      }

      if(row_[0] == 0)
      {
        El::MySQL::DateTime tmp(true, 0, 0);
        return tmp;
      }

      unsigned long* lengths = mysql_fetch_lengths(result_->mysql_res());
      El::MySQL::DateTime tmp(false, row_[0], lengths[0]);

      return tmp;
    }

  }
}

#endif // _NEWSGATE_MESSAGE_BANKSESSIONINFO__2087742441_
